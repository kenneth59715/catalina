head	1.3;
access;
symbols;
locks; strict;
comment	@# @;


1.3
date	2002.01.17.05.50.07;	author kenneth;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.14.20.37.15;	author kenneth;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.12.22.37.33;	author kenneth;	state Exp;
branches;
next	;


desc
@sgid wrapper for user cancel of res
@


1.3
log
@hacked out tons of stuff
@
text
@/*
 * THIS HAS BEEN WEAKENED (NO PATH,OWNERSHIP,PERMISSIONS CHECKS)
 * DO NOT USE FOR SUID ROOT STUFF
 * Since this service is not particularly critical, in the face of any error
 * at all we just report it and quit rather than try to muddle through.
 */

#ifdef sun
int		errno;
extern void	closelog(), exit();
#else
#include <unistd.h>
#include <stdlib.h>
#endif
#include <stdio.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <signal.h>
#include <errno.h>
#include <pwd.h>
#include <string.h>
#include <syslog.h>
#include <regex.h>

/*
 * There are no known security problems with an empty set of
 * environment variables, but provide a safe PATH variable anyway.
 * This provides necessary functionality to programs like SunOS
 * mount(8), which legitimately runs some other program.
 * Also provide a LOGNAME variable, which is the login name of
 * whomever invoked this program.
 */
static char *env[] = {
        "LOGNAME=12345678",
#ifdef sun
        "PATH=/usr/bin:/usr/etc:/usr/ucb",
#else
#if defined(__osf__) || defined(__OSF1__)
        "PATH=/sbin:/usr/sbin:/usr/bin",
#else
#ifdef hpux
        "PATH=/bin:/usr/bin:/etc:/usr/etc",
#else
#ifdef mips
        "PATH=/usr/sbin:/usr/bsd:/sbin:/usr/bin:/usr/etc",
#endif /* mips */
#endif /* hpux */
#endif /* osf */
#endif /* sun */
        (char *)NULL };


static char	program[] = "___USER_CANCEL_RES_PLACEHOLDER___";
static char	arg_pattern[] = "^[_:/a-zA-Z0-9]*$";

#define TOOLONG 17
/* ARGCOUNT doesn't change the execle args */
#define ARGCOUNT 2

main(int argc, char *argv[])
{
char	*arg0;
int	status;
int	re_status;
int	arg_length;
int	i;
regex_t	re;

/* Check for right number of arguments */
/* 1-account, 2-nodes, 3-duration, 4-start_time */
if ( argc != ARGCOUNT ) {
	printf("res_id argument required\n");
	exit(2);
}

/* Check for length of each argument */
for ( i=1; i < ARGCOUNT ; i++ ) {
	if ( strlen(argv[i]) > TOOLONG ) {
		printf("argument exceeds limit\n");
		exit(2);
	}
}

/* check that each argument contains only good characters:
 * '_', '/', ':', a-z, A-Z, 0-9 (no spaces allowed)
 */
if (regcomp(&re, arg_pattern, REG_NEWLINE) != 0 ) {
	printf("argument checking (pattern compile) failed\n");
	exit(2);
}
for ( i=1; i < ARGCOUNT ; i++ ) {
	if (regexec(&re, argv[i], (size_t) 0, NULL, 0) != 0 ) {
		printf("argument checking (regexec) failed\n");
		exit(2);
	}
}

arg0 = program;
/*
 * Set the umask value and change to the preferred current directory.
 */
(void)umask(022);
if (chdir("/") != 0) {
	perror("chdir(/)");
	return 1;
	}
/*
 * Execute the command.  On success execle() does not return.
 */
status = execle(program, arg0, argv[1], (char *)NULL, env);
perror("execle");
return status;
}
@


1.2
log
@removed SIG_HOLD warning
@
text
@d2 2
a3 4
 * cdmount - safe setuid front end to a shell script that mounts a CD ROM
 * Written by Jeff Makey <jeff@@sdsc.edu>, 14 December 1994
 * modified to run user_set_res.py
 *
a24 256
#ifdef hpux
extern void	closelog();
#include <sys/resource.h>
/*
 * HP-UX does not provide this function.  Here it is.
 */
static int getdtablesize()
{
struct rlimit	rl;

if (getrlimit(RLIMIT_NOFILE, &rl) != 0) {
	perror("getrlimit");
	exit(1);
	}
return rl.rlim_cur;
}
#endif

static void setup_logging(ident)
char	*ident;
{
static char	*syslog_ident = (char *)NULL;
int		fd;
struct stat	st;

/*
 * Remember the ident string from the first call, so we don't have to
 * (and are not allowed to) provide it again.
 */
if (syslog_ident == (char *)NULL) {
	syslog_ident = ident;
	/*
	 * Make sure file descriptors 0-2 are open.
	 */
	for (fd = 0; fd <= 2; fd++)
		if (fstat(fd, &st) != 0 && open("/dev/null", 2) != fd) {
			perror("open(/dev/null)");
			exit(1);
			}
	}
#if !defined(__osf__) && !defined(__OSF1__) && !defined(hpux)
openlog(syslog_ident, (LOG_PID|LOG_CONS), LOG_AUTH);
#else
if (openlog(syslog_ident, (LOG_PID|LOG_CONS), LOG_AUTH) != 0) {
	perror("openlog");
	exit(1);
	}
#endif
}

/*
 * Make sure that the path name about to be executed is safe from
 * having its components modified without superuser privileges, and
 * return a pointer to just the final component of the path.
 */
static char *validate_path(path)
char	*path;
{
char		c, *cp, *filename = (char *)NULL;
struct stat	st;

if (*path != '/') {
	(void)syslog(LOG_ERR, "path name \"%s\" must begin with slash", path);
	(void)fprintf(stderr, "Program path name \"%s\" must begin with a slash\n", path);
	return filename;
	}
/*
 * If there is a cleaner way to structure this loop, I don't see it.
 */
cp = &path[1];
for (;;) {
	/*
	 * Save a copy of the character while we temporarily replace
	 * it with a null to truncate the path name.
	 */
	c = *cp;
	*cp = '\0';
	if (lstat(path, &st) != 0) {
		(void)syslog(LOG_ERR, "stat(%s): error %d", path, errno);
		(void)fprintf(stderr, "%s: ", path);
		perror("stat");
		filename = (char *)NULL;
		break;
		}
	/*
	 * Here are the rules: every file/directory in the path name
	 * must be either a regular file or a directory (no symbolic
	 * links, etc., are allowed), be owned by root, and be
	 * unwritable by the group or others.
	 * ownership allowed for kenneth, 15984
	 */
	if (! S_ISDIR(st.st_mode) && ! S_ISREG(st.st_mode)) {
		(void)syslog(LOG_ERR, "%s: not directory nor regular file", path);
		(void)fprintf(stderr, "%s: must be a directory or regular file\n", path);
		filename = (char *)NULL;
		break;
		}
	if (st.st_uid != 0 && st.st_uid != 15984) {
		(void)syslog(LOG_ERR, "%s: not owned by root", path);
		(void)fprintf(stderr, "%s: must be owned by root\n", path);
		filename = (char *)NULL;
		break;
		}
	if (st.st_mode & (S_IWGRP|S_IWOTH)) {
		(void)syslog(LOG_ERR, "%s: writable by group or others", path);
		(void)fprintf(stderr, "%s: must not be writable by group or others\n", path);
		filename = (char *)NULL;
		break;
		}
	/*
	 * If we get to here then there are no known security problems
	 * with the path as far as we have examined it.  Quit looping
	 * if we are at the end of the original path name.
	 */
	if (c == '\0')
		break;		/* normal exit from loop */
	*cp = c;
	/*
	 * Special case for the leading slash.
	 */
	if (cp != &path[1])
		cp++;
	filename = cp;
	/*
	 * Move forward to the next slash, but no farther than the end of the string.
	 */
	while (*cp != '/' && *cp != '\0')
		cp++;
	}
*cp = c;
if (filename != (char *)NULL)
	/*
	 * The final rule is that the full path must point to a
	 * regular file that is executable, not a directory nor some
	 * non-executable file.
	 */
	if (! S_ISREG(st.st_mode) || ! (st.st_mode & S_IXUSR)) {
		(void)syslog(LOG_ERR, "%s: not executable", path);
		(void)fprintf(stderr, "%s: must be a an executable file\n", path);
		filename = (char *)NULL;
		}
return filename;
}

/*
 * Do whatever is necessary to the environment of this process to make
 * it safe to execute a program as root.
 */
static int secure_environment()
{
int		i, opencount;
void		(*oldsig)();

/*
 * Disable any pending alarms.
 */
if (alarm(0) != 0) {
	(void)syslog(LOG_NOTICE, "disabled unexpected alarm");
	(void)fputs("Why was the alarm set?\n", stderr);
	}

/*
 * Close all file descriptors execpt standard input, output, and
 * error, which we made sure were open in setup_logging().  Do this
 * first to make sure we can later open files if necessary.  Since
 * this is sure to close the syslog descriptor, we'll close it
 * explicitly and reopen it after we're done.
 */
opencount = 0;
closelog();
for (i = getdtablesize(); i > 2; i--) {
	if (close(i) == 0) {
		opencount++;
		(void)fprintf(stderr, "Why was file descriptor %d open?\n", i);
		}
	else if (errno != EBADF) {
		perror("close");
		return 1;
		}
	}
setup_logging((char *)NULL);
if (opencount != 0)
	(void)syslog(LOG_NOTICE, "closed %d dangling file descriptor%s", opencount, (opencount == 1 ? "" : "s"));

/*
 * Reset the handling for all signals to the default action.
 */
for (i = 1; i < NSIG; i++) {
	oldsig = signal(i, SIG_DFL);
	if (oldsig == SIG_DFL)
		/* normal case */ ;
	else if (oldsig == SIG_IGN) {
		(void)syslog(LOG_NOTICE, "signal %d set to SIG_IGN", i);
		(void)fprintf(stderr, "Why was signal %d set to SIG_IGN?\n", i);
		}
/*
	else if (oldsig == SIG_HOLD) {
		(void)syslog(LOG_NOTICE, "signal %d set to SIG_HOLD", i);
		(void)fprintf(stderr, "Why was signal %d set to SIG_HOLD?\n", i);
		}
*/
	else if (oldsig == SIG_ERR
#if !defined(__osf__) && !defined(__OSF1__)
		&& i != SIGKILL && i != SIGSTOP
#endif
		) {
		perror("signal");
		return 1;
		}
	else if (oldsig != SIG_ERR) {
		(void)syslog(LOG_NOTICE, "signal %d had handler", i);
		(void)fprintf(stderr, "Why did signal %d have a handler set?\n", i);
		}
	}

/*
 * Detach from all mapped shared memory segments.
 *
 * How would one go about doing this?
 */

return 0;
}

/*
 * Using the process real UID find a a corresponding login name in the
 * password database and use that to set the LOGNAME environment variable.
 */
static int get_username(ptr)
char	*ptr;
{
uid_t		uid;
struct passwd	*pw;

if (strcmp(ptr, "LOGNAME=12345678") != 0) {
	(void)syslog(LOG_ERR, "cannot set LOGNAME");
	(void)fputs("Internal consistency error: cannot set LOGNAME\n", stderr);
	return 1;
	}
errno = 0;
if ((pw = getpwuid(uid = getuid())) == (struct passwd *)NULL) {
	if (errno != 0)
		perror("getpwuid");
	(void)syslog(LOG_ERR, "uid %d not in password file", uid);
	(void)fputs("Cannot find you in the password database.  Sorry.\n", stderr);
	return 1;
	}
(void)syslog(LOG_INFO, "uid %d is user %s", uid, pw->pw_name);
if (strlen(pw->pw_name) > 8) {
	(void)syslog(LOG_ERR, "user name \"%s\" longer than 8 characters", pw->pw_name);
	(void)fprintf(stderr, "Warning: user name \"%s\" truncated to 8 characters in LOGNAME environment variable.\n", pw->pw_name);
	}
(void)strncpy(&ptr[8], pw->pw_name, 8);
return 0;
}

d34 1
a34 1
	"LOGNAME=12345678",
d36 1
a36 1
	"PATH=/usr/bin:/usr/etc:/usr/ucb",
d39 1
a39 1
	"PATH=/sbin:/usr/sbin:/usr/bin",
d42 1
a42 1
	"PATH=/bin:/usr/bin:/etc:/usr/etc",
d45 1
a45 1
	"PATH=/usr/sbin:/usr/bsd:/sbin:/usr/bin:/usr/etc",
d50 2
a51 1
	(char *)NULL };
a52 1
/*static char	program[] = "/usr/lbin/cdmount.sh";*/
d54 1
a54 1
static char	arg_pattern[] = "^[a-zA-Z0-9]*$";
d98 1
a98 5
setup_logging("user_cancel_res");
if ((arg0 = validate_path(program)) == (char *)NULL
 || secure_environment() != 0
 || get_username(env[0]) != 0)
	return 1;
a106 1
closelog();
a111 2
setup_logging((char *)NULL);
(void)syslog(LOG_NOTICE, "execle(%s) failed with error %d", program, errno);
@


1.1
log
@Initial revision
@
text
@d222 1
d227 1
@
