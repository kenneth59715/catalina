head	1.14;
access;
symbols;
locks; strict;
comment	@# @;


1.14
date	2005.03.22.23.59.55;	author kenneth;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.05.01.17.10;	author kenneth;	state Exp;
branches;
next	1.12;

1.12
date	2004.02.05.17.56.07;	author kenneth;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.02.20.06.18;	author kenneth;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.09.17.54.08;	author kenneth;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.23.15.57.28;	author kenneth;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.24.17.52.59;	author kenneth;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.11.17.51.48;	author kenneth;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.09.21.25.35;	author kenneth;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.09.03.25.55;	author kenneth;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.01.21.44.14;	author kenneth;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.17.05.49.14;	author kenneth;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.14.20.37.47;	author kenneth;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.12.22.37.08;	author kenneth;	state Exp;
branches;
next	;


desc
@sgid wrapper for user set of res
@


1.14
log
@interactivebig
@
text
@/*
 * THIS HAS BEEN WEAKENED (NO PATH,OWNERSHIP,PERMISSIONS CHECKS)
 * DO NOT USE FOR SUID ROOT STUFF
 * Since this service is not particularly critical, in the face of any error
 * at all we just report it and quit rather than try to muddle through.
 */

#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <signal.h>
#include <errno.h>
#include <pwd.h>
#include <string.h>
#include <syslog.h>
#include <regex.h>

/*
 * There are no known security problems with an empty set of
 * environment variables, but provide a safe PATH variable anyway.
 * This provides necessary functionality to programs like SunOS
 * mount(8), which legitimately runs some other program.
 * Also provide a LOGNAME variable, which is the login name of
 * whomever invoked this program.
 */
static char *env[] = {
        "LOGNAME=12345678",
        "TZ=GMT0",
#ifdef sun
        "PATH=/usr/bin:/usr/etc:/usr/ucb",
#else
#if defined(__osf__) || defined(__OSF1__)
        "PATH=/sbin:/usr/sbin:/usr/bin",
#else
#ifdef hpux
        "PATH=/bin:/usr/bin:/etc:/usr/etc",
#else
#ifdef mips
        "PATH=/usr/sbin:/usr/bsd:/sbin:/usr/bin:/usr/etc",
#endif /* mips */
#endif /* hpux */
#endif /* osf */
#endif /* sun */
        (char *)NULL };

static char	program[] = "___USER_SET_RES_PLACEHOLDER___";
static char	arg_pattern[] = "^[-.=,@@_:/a-zA-Z0-9#+]*$";
static char	tz_pattern[] = "^[A-Z0-9]*$";

#define TOOLONG 100
/* ARGCOUNT doesn't change the execle args */
#define MAXARGCOUNT 10
#define MINARGCOUNT 7

main(int argc, char *argv[])
{
char	*arg0;
char	*timezone;
int	status;
int	re_status;
int	arg_length;
int	i;
regex_t	re;
regex_t	tz_re;

/* Check for right number of arguments */
/* 1-account, 2-nodes, 3-duration, 4-start_time, 5-end_time, 6-email, 7-sharedmap */
if ( argc < MINARGCOUNT || argc > MAXARGCOUNT ) {
	printf("Wrong argument count!\n");
	printf("Usage: user_set_res --account=<account> --nodes=<number of nodes>|--maxmodes=<max number of nodes> --duration=<duration(sec)> --earliest_start=<earliest start time(HH:MM_mm/dd/yyyy or epoch seconds)> --latest_end=<latest end time(HH:MM_mm/dd/yyyy or epoch seconds)> --email=<email address> [--sharedmap=<1#type:node_shared#cpu:1+memory:1>] [--featurelist=<comma-delimited list of node features>] [--qoslist=<comma-delimited list of allowed QOS>]\n");
	exit(2);
}

/* Check for length of each argument */
for ( i=1; i < argc ; i++ ) {
	if ( strlen(argv[i]) > TOOLONG ) {
		printf("argument exceeds limit\n");
		exit(2);
	}
}

/* check that each argument contains only good characters:
 * '_', '/', ':', a-z, A-Z, 0-9, @@, #, + (no spaces allowed)
 */
if (regcomp(&re, arg_pattern, REG_NEWLINE) != 0 ) {
	printf("argument checking (pattern compile) failed\n");
	exit(2);
}
for ( i=1; i < argc ; i++ ) {
        /*printf("checking %s", argv[i]);*/
	if (regexec(&re, argv[i], (size_t) 0, NULL, 0) != 0 ) {
		printf("argument checking (regexec) failed\n");
		exit(2);
	}
}

arg0 = program;
/*
 * Set the TZ for environment
 */
timezone = getenv("TZ");
if ( timezone == NULL ) {
	setenv("TZ", "GMT0", 1);
}
if ( strnlen(getenv("TZ"), TOOLONG + 1) > TOOLONG ) {
	printf("TZ exceeds limit of %d characters\n",TOOLONG);
	exit(2);
}
if (regcomp(&tz_re, tz_pattern, REG_NEWLINE) != 0 ) {
	printf("TZ format checking (pattern compile) failed\n");
	exit(2);
}
if (regexec(&re, getenv("TZ"), (size_t) 0, NULL, 0) != 0 ) {
	printf("TZ checking (regexec) failed\n");
	exit(2);
}
timezone = (char *)malloc(strlen("TZ=") + strlen(getenv("TZ")) + 1);
strcpy(timezone,"TZ=");
strcat(timezone,getenv("TZ"));
i = 0;
while ( 1 ) {
	if ( env[i] == "TZ=GMT0" ) {
		env[i] = timezone;
		break;
	}
	if ( env[i] == NULL ) {
		break;
	}
	i = i + 1;
}

/*
 * Set the umask value and change to the preferred current directory.
 */
(void)umask(002);
if (chdir("/") != 0) {
	perror("chdir(/)");
	return 1;
	}
/*
 * Execute the command.  On success execle() does not return.
 */
if (argc == 10) {
	status = execle(program, arg0, argv[1], argv[2], argv[3], argv[4], argv[5], argv[6], argv[7], argv[8], argv[9], (char *)NULL, env);
}
if (argc == 9) {
	status = execle(program, arg0, argv[1], argv[2], argv[3], argv[4], argv[5], argv[6], argv[7], argv[8], (char *)NULL, env);
}
if (argc == 8) {
	status = execle(program, arg0, argv[1], argv[2], argv[3], argv[4], argv[5], argv[6], argv[7], (char *)NULL, env);
}
if (argc == 7) {
	status = execle(program, arg0, argv[1], argv[2], argv[3], argv[4], argv[5], argv[6], (char *)NULL, env);
}
perror("execle");
return status;
}
@


1.13
log
@use long opts, longer arg lengths
@
text
@d54 1
a54 1
#define MAXARGCOUNT 9
d72 1
a72 1
	printf("Usage: user_set_res --account=<account> --nodes=<number of nodes>|--maxmodes=<max number of nodes> --duration=<duration(sec)> --earliest_start=<earliest start time(HH:MM_mm/dd/yyyy or epoch seconds)> --latest_end=<latest end time(HH:MM_mm/dd/yyyy or epoch seconds)> --email=<email address> [--sharedmap=<1#type:node_shared#cpu:1+memory:1>] [--featurelist=<comma-delimited list of node features>]\n");
d145 3
@


1.12
log
@smp
@
text
@d49 1
a49 1
static char	arg_pattern[] = "^[-.@@_:/a-zA-Z0-9#+]*$";
d52 1
a52 1
#define TOOLONG 37
d54 2
a55 1
#define ARGCOUNT 8
d70 1
a70 1
if ( argc != ARGCOUNT && argc != ARGCOUNT - 1) {
d72 1
a72 1
	printf("Usage: user_set_res <account> <number of nodes (n or nMAX)> <duration(sec)> <earliest start time(HH:MM_mm/dd/yyyy or epoch seconds)> <latest end time(HH:MM_mm/dd/yyyy or epoch seconds)> <email address> [<sharedmap>]\n");
d92 1
d145 9
a153 1
status = execle(program, arg0, argv[1], argv[2], argv[3], argv[4], argv[5], argv[6], argv[7], (char *)NULL, env);
@


1.11
log
@fixed strnlen
@
text
@d49 1
a49 1
static char	arg_pattern[] = "^[-.@@_:/a-zA-Z0-9]*$";
d54 1
a54 1
#define ARGCOUNT 7
d68 2
a69 2
/* 1-account, 2-nodes, 3-duration, 4-start_time, 5-end_time, 6-email */
if ( argc != ARGCOUNT ) {
d71 1
a71 1
	printf("Usage: user_set_res <account> <number of nodes (n or nMAX)> <duration(sec)> <earliest start time(HH:MM_mm/dd/yyyy or epoch seconds)> <latest end time(HH:MM_mm/dd/yyyy or epoch seconds)> <email address>\n");
d76 1
a76 1
for ( i=1; i < ARGCOUNT ; i++ ) {
d84 1
a84 1
 * '_', '/', ':', a-z, A-Z, 0-9 (no spaces allowed)
d90 1
a90 1
for ( i=1; i < ARGCOUNT ; i++ ) {
d143 1
a143 1
status = execle(program, arg0, argv[1], argv[2], argv[3], argv[4], argv[5], argv[6], (char *)NULL, env);
@


1.10
log
@increased TOOLONG to 37
@
text
@d105 1
a105 1
if ( strnlen(getenv("TZ")) > TOOLONG ) {
@


1.9
log
@add '-' as an acceptable argument character
@
text
@d52 1
a52 1
#define TOOLONG 17
@


1.8
log
@added check and set for TZ not set
@
text
@d49 1
a49 1
static char	arg_pattern[] = "^[.@@_:/a-zA-Z0-9]*$";
@


1.7
log
@added max_resource_int
@
text
@d101 4
@


1.6
log
@print out neater usage string
@
text
@d71 1
a71 1
	printf("Usage: user_set_res <account> <number of nodes> <duration(sec)> <earliest start time(HH:MM_mm/dd/yyyy or epoch seconds)> <latest end time(HH:MM_mm/dd/yyyy or epoch seconds)> <email address>\n");
@


1.5
log
@dst tag -1
@
text
@d70 2
a71 1
	printf("account, number of nodes, duration(sec), earliest start time(HH:MM_mm/dd/yyyy), latest end time(HH:MM_mm/dd/yyyy) and email arguments required\n");
@


1.4
log
@add notification and get_broken_reservations_tuple
@
text
@a7 4
#ifdef sun
int		errno;
extern void	closelog(), exit();
#else
a9 1
#endif
d30 1
d50 1
d59 1
d65 1
d98 30
d130 1
a130 1
(void)umask(022);
@


1.3
log
@hack out tons of stuff
@
text
@d53 1
a53 1
static char	arg_pattern[] = "^[_:/a-zA-Z0-9]*$";
d57 1
a57 1
#define ARGCOUNT 6
d69 1
a69 1
/* 1-account, 2-nodes, 3-duration, 4-start_time */
d71 1
a71 1
	printf("account, number of nodes, duration(sec), earliest start time(HH:MM_mm/dd/yyyy), and latest end time(HH:MM_mm/dd/yyyy) arguments required\n");
d109 1
a109 1
status = execle(program, arg0, argv[1], argv[2], argv[3], argv[4], argv[5], (char *)NULL, env);
@


1.2
log
@removed SIG_HOLD warning
@
text
@d2 2
a3 4
 * cdmount - safe setuid front end to a shell script that mounts a CD ROM
 * Written by Jeff Makey <jeff@@sdsc.edu>, 14 December 1994
 * modified to run user_set_res.py
 *
a24 256
#ifdef hpux
extern void	closelog();
#include <sys/resource.h>
/*
 * HP-UX does not provide this function.  Here it is.
 */
static int getdtablesize()
{
struct rlimit	rl;

if (getrlimit(RLIMIT_NOFILE, &rl) != 0) {
	perror("getrlimit");
	exit(1);
	}
return rl.rlim_cur;
}
#endif

static void setup_logging(ident)
char	*ident;
{
static char	*syslog_ident = (char *)NULL;
int		fd;
struct stat	st;

/*
 * Remember the ident string from the first call, so we don't have to
 * (and are not allowed to) provide it again.
 */
if (syslog_ident == (char *)NULL) {
	syslog_ident = ident;
	/*
	 * Make sure file descriptors 0-2 are open.
	 */
	for (fd = 0; fd <= 2; fd++)
		if (fstat(fd, &st) != 0 && open("/dev/null", 2) != fd) {
			perror("open(/dev/null)");
			exit(1);
			}
	}
#if !defined(__osf__) && !defined(__OSF1__) && !defined(hpux)
openlog(syslog_ident, (LOG_PID|LOG_CONS), LOG_AUTH);
#else
if (openlog(syslog_ident, (LOG_PID|LOG_CONS), LOG_AUTH) != 0) {
	perror("openlog");
	exit(1);
	}
#endif
}

/*
 * Make sure that the path name about to be executed is safe from
 * having its components modified without superuser privileges, and
 * return a pointer to just the final component of the path.
 */
static char *validate_path(path)
char	*path;
{
char		c, *cp, *filename = (char *)NULL;
struct stat	st;

if (*path != '/') {
	(void)syslog(LOG_ERR, "path name \"%s\" must begin with slash", path);
	(void)fprintf(stderr, "Program path name \"%s\" must begin with a slash\n", path);
	return filename;
	}
/*
 * If there is a cleaner way to structure this loop, I don't see it.
 */
cp = &path[1];
for (;;) {
	/*
	 * Save a copy of the character while we temporarily replace
	 * it with a null to truncate the path name.
	 */
	c = *cp;
	*cp = '\0';
	if (lstat(path, &st) != 0) {
		(void)syslog(LOG_ERR, "stat(%s): error %d", path, errno);
		(void)fprintf(stderr, "%s: ", path);
		perror("stat");
		filename = (char *)NULL;
		break;
		}
	/*
	 * Here are the rules: every file/directory in the path name
	 * must be either a regular file or a directory (no symbolic
	 * links, etc., are allowed), be owned by root, and be
	 * unwritable by the group or others.
	 * ownership allowed for kenneth, 15984
	 */
	if (! S_ISDIR(st.st_mode) && ! S_ISREG(st.st_mode)) {
		(void)syslog(LOG_ERR, "%s: not directory nor regular file", path);
		(void)fprintf(stderr, "%s: must be a directory or regular file\n", path);
		filename = (char *)NULL;
		break;
		}
	if (st.st_uid != 0 && st.st_uid != 15984) {
		(void)syslog(LOG_ERR, "%s: not owned by root", path);
		(void)fprintf(stderr, "%s: must be owned by root\n", path);
		filename = (char *)NULL;
		break;
		}
	if (st.st_mode & (S_IWGRP|S_IWOTH)) {
		(void)syslog(LOG_ERR, "%s: writable by group or others", path);
		(void)fprintf(stderr, "%s: must not be writable by group or others\n", path);
		filename = (char *)NULL;
		break;
		}
	/*
	 * If we get to here then there are no known security problems
	 * with the path as far as we have examined it.  Quit looping
	 * if we are at the end of the original path name.
	 */
	if (c == '\0')
		break;		/* normal exit from loop */
	*cp = c;
	/*
	 * Special case for the leading slash.
	 */
	if (cp != &path[1])
		cp++;
	filename = cp;
	/*
	 * Move forward to the next slash, but no farther than the end of the string.
	 */
	while (*cp != '/' && *cp != '\0')
		cp++;
	}
*cp = c;
if (filename != (char *)NULL)
	/*
	 * The final rule is that the full path must point to a
	 * regular file that is executable, not a directory nor some
	 * non-executable file.
	 */
	if (! S_ISREG(st.st_mode) || ! (st.st_mode & S_IXUSR)) {
		(void)syslog(LOG_ERR, "%s: not executable", path);
		(void)fprintf(stderr, "%s: must be a an executable file\n", path);
		filename = (char *)NULL;
		}
return filename;
}

/*
 * Do whatever is necessary to the environment of this process to make
 * it safe to execute a program as root.
 */
static int secure_environment()
{
int		i, opencount;
void		(*oldsig)();

/*
 * Disable any pending alarms.
 */
if (alarm(0) != 0) {
	(void)syslog(LOG_NOTICE, "disabled unexpected alarm");
	(void)fputs("Why was the alarm set?\n", stderr);
	}

/*
 * Close all file descriptors execpt standard input, output, and
 * error, which we made sure were open in setup_logging().  Do this
 * first to make sure we can later open files if necessary.  Since
 * this is sure to close the syslog descriptor, we'll close it
 * explicitly and reopen it after we're done.
 */
opencount = 0;
closelog();
for (i = getdtablesize(); i > 2; i--) {
	if (close(i) == 0) {
		opencount++;
		(void)fprintf(stderr, "Why was file descriptor %d open?\n", i);
		}
	else if (errno != EBADF) {
		perror("close");
		return 1;
		}
	}
setup_logging((char *)NULL);
if (opencount != 0)
	(void)syslog(LOG_NOTICE, "closed %d dangling file descriptor%s", opencount, (opencount == 1 ? "" : "s"));

/*
 * Reset the handling for all signals to the default action.
 */
for (i = 1; i < NSIG; i++) {
	oldsig = signal(i, SIG_DFL);
	if (oldsig == SIG_DFL)
		/* normal case */ ;
	else if (oldsig == SIG_IGN) {
		(void)syslog(LOG_NOTICE, "signal %d set to SIG_IGN", i);
		(void)fprintf(stderr, "Why was signal %d set to SIG_IGN?\n", i);
		}
/*
	else if (oldsig == SIG_HOLD) {
		(void)syslog(LOG_NOTICE, "signal %d set to SIG_HOLD", i);
		(void)fprintf(stderr, "Why was signal %d set to SIG_HOLD?\n", i);
		}
*/
	else if (oldsig == SIG_ERR
#if !defined(__osf__) && !defined(__OSF1__)
		&& i != SIGKILL && i != SIGSTOP
#endif
		) {
		perror("signal");
		return 1;
		}
	else if (oldsig != SIG_ERR) {
		(void)syslog(LOG_NOTICE, "signal %d had handler", i);
		(void)fprintf(stderr, "Why did signal %d have a handler set?\n", i);
		}
	}

/*
 * Detach from all mapped shared memory segments.
 *
 * How would one go about doing this?
 */

return 0;
}

/*
 * Using the process real UID find a a corresponding login name in the
 * password database and use that to set the LOGNAME environment variable.
 */
static int get_username(ptr)
char	*ptr;
{
uid_t		uid;
struct passwd	*pw;

if (strcmp(ptr, "LOGNAME=12345678") != 0) {
	(void)syslog(LOG_ERR, "cannot set LOGNAME");
	(void)fputs("Internal consistency error: cannot set LOGNAME\n", stderr);
	return 1;
	}
errno = 0;
if ((pw = getpwuid(uid = getuid())) == (struct passwd *)NULL) {
	if (errno != 0)
		perror("getpwuid");
	(void)syslog(LOG_ERR, "uid %d not in password file", uid);
	(void)fputs("Cannot find you in the password database.  Sorry.\n", stderr);
	return 1;
	}
(void)syslog(LOG_INFO, "uid %d is user %s", uid, pw->pw_name);
if (strlen(pw->pw_name) > 8) {
	(void)syslog(LOG_ERR, "user name \"%s\" longer than 8 characters", pw->pw_name);
	(void)fprintf(stderr, "Warning: user name \"%s\" truncated to 8 characters in LOGNAME environment variable.\n", pw->pw_name);
	}
(void)strncpy(&ptr[8], pw->pw_name, 8);
return 0;
}

d34 1
a34 1
	"LOGNAME=12345678",
d36 1
a36 1
	"PATH=/usr/bin:/usr/etc:/usr/ucb",
d39 1
a39 1
	"PATH=/sbin:/usr/sbin:/usr/bin",
d42 1
a42 1
	"PATH=/bin:/usr/bin:/etc:/usr/etc",
d45 1
a45 1
	"PATH=/usr/sbin:/usr/bsd:/sbin:/usr/bin:/usr/etc",
d50 1
a50 1
	(char *)NULL };
a51 1
/*static char	program[] = "/usr/lbin/cdmount.sh";*/
d97 1
a97 5
setup_logging("user_set_res");
if ((arg0 = validate_path(program)) == (char *)NULL
 || secure_environment() != 0
 || get_username(env[0]) != 0)
	return 1;
a105 1
closelog();
a110 2
setup_logging((char *)NULL);
(void)syslog(LOG_NOTICE, "execle(%s) failed with error %d", program, errno);
@


1.1
log
@Initial revision
@
text
@d222 1
d227 1
@
