head	1.1;
access;
symbols;
locks; strict;
comment	@# @;


1.1
date	2003.01.08.19.22.59;	author kenneth;	state Exp;
branches;
next	;


desc
@query disk allocation
@


1.1
log
@Initial revision
@
text
@/* C program to get quota info */
#include <stdio.h>
#include <math.h>
#include <jfs/quota.h>
#include <errno.h>
/* For getpwent */
#include <sys/types.h>
#include <pwd.h>
/* For memcpy */

int errno;

main (int argc, char *argv[]) {
	int Cmd, ID;
	char *Addr, *Path;
	int rc, error_code, number_of_objs;
	char *username;
	char *job_user, *job_group, *machine_name;

	struct dqblk *dqblk_ptr = NULL;

	struct pwinfo {
		struct passwd *passwdptr;
		struct pwinfo *next_ptr;
	};
	struct pwinfo *first_pw_ptr = NULL;
	struct pwinfo *new_pw_ptr = NULL;
	struct pwinfo *pwnode = NULL;

	struct jobinfo {
		char *userptr;
		struct dqblk *dqblkptr;
		struct jobinfo *next_ptr;
	};
	struct jobinfo *first_job_ptr = NULL;
	struct jobinfo *new_job_ptr = NULL;
	struct jobinfo *jobnode = NULL;

	struct passwd *passwd_ptr,*new_passwd_ptr;

	/* get a list of users */
	setpwent();
	while ( 1 ) {
		printf("getpwent\n");
		passwd_ptr = getpwent();
		if (passwd_ptr == NULL) {
			if (errno == ENOATTR) {
				printf("Corrupted entry\n");
				/* Corrupted pw entry.  Maybe should exit? */
				continue;
			} else {
				printf("End of entries\n");
				/* No more entries? */
				break;
			}
		}
		printf("Non-NULL entry\n");
		printf("username (%s)\n", passwd_ptr->pw_name);
		new_passwd_ptr = (struct passwd *)malloc(sizeof(struct passwd));
		/* memcpy doesn't work, since it copies the pointers within
		 * the passwd structure to the structure referenced by
		 * new_passwd_ptr.  When getpwent() runs again, the referenced
		 * data is written over, only the pointers are retained.
		 * So, need to explicitly copy each item from the passwd struct.
		memcpy(new_passwd_ptr,passwd_ptr,sizeof(struct passwd));
		 *
		 */
		new_passwd_ptr->pw_name = (char *)malloc(strlen(passwd_ptr->pw_name) + 1);
		strncpy(new_passwd_ptr->pw_name, passwd_ptr->pw_name, strlen(passwd_ptr->pw_name) + 1);
		new_passwd_ptr->pw_passwd = (char *)malloc(strlen(passwd_ptr->pw_passwd) + 1);
		strncpy(new_passwd_ptr->pw_passwd, passwd_ptr->pw_passwd, strlen(passwd_ptr->pw_passwd) + 1);
		new_passwd_ptr->pw_uid = passwd_ptr->pw_uid;
		new_passwd_ptr->pw_gid = passwd_ptr->pw_gid;
		new_passwd_ptr->pw_gecos = (char *)malloc(strlen(passwd_ptr->pw_gecos) + 1);
		strncpy(new_passwd_ptr->pw_gecos, passwd_ptr->pw_gecos, strlen(passwd_ptr->pw_gecos) + 1);
		new_passwd_ptr->pw_dir = (char *)malloc(strlen(passwd_ptr->pw_dir) + 1);
		strncpy(new_passwd_ptr->pw_dir, passwd_ptr->pw_dir, strlen(passwd_ptr->pw_dir) + 1);
		new_passwd_ptr->pw_shell = (char *)malloc(strlen(passwd_ptr->pw_shell) + 1);
		strncpy(new_passwd_ptr->pw_shell, passwd_ptr->pw_shell, strlen(passwd_ptr->pw_shell) + 1);
		new_pw_ptr = (struct pwinfo *)malloc(sizeof(struct pwinfo));
		new_pw_ptr->next_ptr = first_pw_ptr;
		new_pw_ptr->passwdptr = new_passwd_ptr;
		printf("new_pw_ptr->passwdptr->pw_name (%s)\n", new_pw_ptr->passwdptr->pw_name);
		printf("new_pw_ptr->next_ptr->passwdptr->pw_name (%s)\n", new_pw_ptr->next_ptr->passwdptr->pw_name);
		printf("new_pw_ptr->passwdptr (%d)\n", new_pw_ptr->passwdptr);
		printf("new_pw_ptr->next_ptr->passwdptr (%d)\n", new_pw_ptr->next_ptr->passwdptr);
		first_pw_ptr = new_pw_ptr;
	}
	endpwent();

	/* For each user, get quota info */

	new_pw_ptr = first_pw_ptr;
	while ( new_pw_ptr != NULL ) {
		dqblk_ptr = (struct dqblk *)malloc(sizeof(struct dqblk));
		rc = quotactl(argv[1], QCMD(Q_GETQUOTA,USRQUOTA), new_pw_ptr->passwdptr->pw_uid, dqblk_ptr);
		printf("rc is (%d)\n", rc);
		if ( rc == -1 ) {
			printf("errno (%d)\n", errno);
		}
		printf("username (%s)\n", new_pw_ptr->passwdptr->pw_name);
		printf("new_pw_ptr->passwdptr (%d)\n", new_pw_ptr->passwdptr);
		printf("hardlimit (%d)\n", dqblk_ptr->dqb_bhardlimit);
		printf("softlimit (%d)\n", dqblk_ptr->dqb_bsoftlimit);
		printf("currentblocks (%d)\n", dqblk_ptr->dqb_curblocks);
		printf("ihardlimit (%d)\n", dqblk_ptr->dqb_ihardlimit);
		printf("isoftlimit (%d)\n", dqblk_ptr->dqb_isoftlimit);
		printf("curinodes (%d)\n", dqblk_ptr->dqb_curinodes);
		new_job_ptr = (struct jobinfo *)malloc(sizeof(struct jobinfo));
		new_job_ptr->next_ptr = first_job_ptr;
		new_job_ptr->dqblkptr = dqblk_ptr;
		new_job_ptr->userptr = (char *)malloc(sizeof(new_pw_ptr->passwdptr->pw_name));
		strncpy(new_job_ptr->userptr, new_pw_ptr->passwdptr->pw_name, sizeof(new_pw_ptr->passwdptr->pw_name));
		first_job_ptr = new_job_ptr;

		new_pw_ptr = new_pw_ptr->next_ptr;
	}

	new_job_ptr = first_job_ptr;
	while ( new_job_ptr != NULL ) {
		printf("username (%s)\n", new_job_ptr->userptr);
		printf("hardlimit (%d)\n", new_job_ptr->dqblkptr->dqb_bhardlimit);
		printf("softlimit (%d)\n", new_job_ptr->dqblkptr->dqb_bsoftlimit);
		printf("currentblocks (%d)\n", new_job_ptr->dqblkptr->dqb_curblocks);
		printf("ihardlimit (%d)\n", new_job_ptr->dqblkptr->dqb_ihardlimit);
		printf("isoftlimit (%d)\n", new_job_ptr->dqblkptr->dqb_isoftlimit);
		printf("curinodes (%d)\n", new_job_ptr->dqblkptr->dqb_curinodes);
		new_job_ptr = new_job_ptr->next_ptr;
	}
	printf("qj FINISHED\n");
}
@
