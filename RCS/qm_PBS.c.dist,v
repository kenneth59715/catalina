head	1.3;
access;
symbols;
locks; strict;
comment	@# @;


1.3
date	2002.01.16.19.22.07;	author kenneth;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.14.20.35.15;	author kenneth;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.11.20.24.05;	author kenneth;	state Exp;
branches;
next	;


desc
@query machines
@


1.3
log
@added print of qm FINISHED
@
text
@/* utility for getting job info */
#include <pbs_error.h>
#include <pbs_ifl.h>
#include <string.h>

main () {
	int pbs_connect_id, disconnect_return;
	extern char *pbs_server;
	/*struct attrl *attrib;*/
	struct batch_status *node_status;
	struct batch_status *temp_node_status;
	struct attrl *temp_attrib;

	pbs_connect_id = 0;
	disconnect_return = 0;
	printf("pbs_server (%i)\n", pbs_server);
	pbs_connect_id = pbs_connect(pbs_server);
	if ( pbs_connect_id < 0 ) {
		exit(pbs_connect_id);
	}
	printf("pbs_connect_id (%i)\n", pbs_connect_id);
	node_status = pbs_statnode(pbs_connect_id, NULL, NULL, NULL);
	if ( node_status != NULL ) {
		temp_node_status = node_status;
		while ( temp_node_status != NULL ) {
			printf("node_name#cat_sep#%s#cat_delim#", temp_node_status->name);
			temp_attrib = temp_node_status->attribs;
			while ( temp_attrib != NULL ) {
				printf("%s#cat_sep#%s#cat_sep#%s#cat_delim#", temp_attrib->name, temp_attrib->resource, temp_attrib->value);
				temp_attrib = temp_attrib->next;
			}
			printf("\n");
			temp_node_status = temp_node_status->next;
		}
	} else {
		printf("node_status is Null\n");
	}
	disconnect_return = pbs_disconnect(pbs_connect_id);
	printf("disconnect_return (%i)\n", disconnect_return);
	pbs_statfree(node_status);
	printf("qm FINISHED\n");
}
@


1.2
log
@changed to PBS
@
text
@d18 3
d41 1
@


1.1
log
@Initial revision
@
text
@d1 27
a27 68
/* adapted from IBM examples */
#include "/usr/lpp/LoadL/full/include/llapi.h" 
#define MAXCLASS 1000

main(int argc,char *argv[]){ 
	LL_element *queryObject=NULL, *machine=NULL, *Adapter=NULL; 
	int rc, num, err, index;
	int Disk, Cpus, Max_Starters, Memory, MachineStartdState, AdapterAvailWindowCount, AdapterTotalWindowCount, PoolListSize;
	char **AvailableClasses, **ConfiguredClasses, **FeatureList; 
	char *State, *Machine, *Arch, *OpSys, *AdapterName, *AdapterCommInterface; 
	int **Pool;

	/* Initialize the query for machines */ 
	queryObject = ll_query(MACHINES); 

	rc = ll_set_request(queryObject,QUERY_ALL,NULL,ALL_DATA); 

	/* Request the objects from the Negotiator daemon */ 
	machine = ll_get_objs(queryObject,LL_CM,NULL,&num,&err); 

	/* Did we get a list of objects ? */ 
	if (machine == NULL) { 
		printf("  ll_get_objs returned a NULL object.\n"); 
		printf("  err = %d\n",err); 
	} else { 
		/* Loop through the list and process */ 
		while(machine) { 
			rc = ll_get_data(machine,LL_MachineName,&Machine); 
			if (!rc) { 
				printf("#cat_delim#Machine:%s",Machine); 
				free(Machine); 
			} 
			rc = ll_get_data(machine,LL_MachineArchitecture,&Arch); 
			if (!rc) { 
				printf("#cat_delim#Arch:%s",Arch); 
				free(Arch); 
			} 
			rc = ll_get_data(machine,LL_MachineOperatingSystem,&OpSys); 
			if (!rc) { 
				printf("#cat_delim#OpSys:%s",OpSys); 
				free(OpSys); 
			} 
			rc = ll_get_data(machine,LL_MachineDisk,&Disk); 
			if (!rc) { 
				printf("#cat_delim#Disk:%d",Disk); 
			} 
			rc = ll_get_data(machine,LL_MachinePoolList,&Pool); 
			rc = ll_get_data(machine,LL_MachinePoolListSize,&PoolListSize); 
			printf("#cat_delim#Pool:");
			for (index = 0; index < PoolListSize ; index++) {
				printf("%d", *(Pool + index));
				if ( index < PoolListSize - 1 ) {
					printf("+");
				}
			}
			free(Pool);
			rc = ll_get_data(machine,LL_MachineConfiguredClassList,&ConfiguredClasses); 
			if (!rc) { 
				printf("#cat_delim#ConfiguredClasses:"); 
				for ( index = 0 ; *(ConfiguredClasses + index) != NULL  ; index++ ) {  
					printf("%s",*(ConfiguredClasses + index)); 
					if ( *(ConfiguredClasses + index + 1 ) != NULL) {
						printf("+");
					}
				}
				free(ConfiguredClasses); 
			} else {
				printf("Failed to get Configured Classes: %d\n", rc);
a28 61
			rc = ll_get_data(machine,LL_MachineAvailableClassList,&AvailableClasses); 
			if (!rc) { 
				printf("#cat_delim#AvailableClasses:"); 
				for ( index = 0 ; *(AvailableClasses + index) != NULL  ; index++ ) {  
					printf("%s",*(AvailableClasses + index)); 
					if ( *(AvailableClasses + index + 1) != NULL) {
						printf("+");
					}
				}
				free(AvailableClasses); 
			} else {
				printf("Failed to get Available Classes: %d\n", rc);
			}
			rc = ll_get_data(machine,LL_MachineFeatureList,&FeatureList); 
			if (!rc) { 
				printf("#cat_delim#Feature:");
				for ( index = 0 ; *(FeatureList + index) != NULL  ; index++ ) {  
					printf("%s",*(FeatureList + index)); 
					if ( *(FeatureList + index + 1) != NULL) {
						printf("+");
					}
				}
				free(FeatureList); 
			} else {
				printf("Failed to get FeatureList: %d", rc);
			}
			rc = ll_get_data(machine,LL_MachineMaxTasks,&Max_Starters); 
			if (!rc) { 
				printf("#cat_delim#Max_Starters:%d",Max_Starters); 
			} 
			rc = ll_get_data(machine,LL_MachineRealMemory,&Memory); 
			if (!rc) { 
				printf("#cat_delim#Memory:%d",Memory); 
			} 
			rc = ll_get_data(machine,LL_MachineCPUs,&Cpus); 
			if (!rc) { 
				printf("#cat_delim#Cpus:%d",Cpus); 
			} 
			rc = ll_get_data(machine,LL_MachineStartdState,&State); 
			if (!rc) { 
				printf("#cat_delim#State:%s",State); 
				free(State); 
			} 
/*
			rc = ll_get_data(machine,LL_MachineGetFirstAdapter,&Adapter); 
			if (!rc) { 
				rc = ll_get_data(Adapter,LL_AdapterAvailWindowCount,&AdapterAvailWindowCount); 
				if (!rc) { 
					printf("AdapterAvailWindowcount = %d\n",AdapterAvailWindowCount); 
				} 
				rc = ll_get_data(Adapter,LL_AdapterTotalWindowCount,&AdapterTotalWindowCount); 
				if (!rc) { 
				printf("AdapterTotalWindowcount = %d\n",AdapterTotalWindowCount); 
				} 
				rc = ll_get_data(Adapter,LL_AdapterName,&AdapterName); 
				if (!rc) { 
					printf("AdapterName = %s\n",AdapterName); 
					free(AdapterName);
				} 
			} 
*/
d30 9
a38 12
			machine = ll_next_obj(queryObject); 
		} 
	} 

             /* free objects obtained from Negotiator */ 
             rc = ll_free_objs(queryObject); 

             /* free query element */ 
             rc = ll_deallocate(queryObject); 
      } 


@
