head	1.1;
access;
symbols;
locks; strict;
comment	@# @;


1.1
date	2001.09.12.22.27.41;	author kenneth;	state Exp;
branches;
next	;


desc
@modify a reservation
@


1.1
log
@Initial revision
@
text
@#!___PYTHON_PATH_PLACEHOLDER___
# python script for creating a reservation
# times are in epoch
#options = ['earliest_start=', 'latest_end=', 'duration=', 'resource_amount=', 'job_restriction=', 'job_restriction_file=' 'node_restriction=', 'node_restriction_file=', 'privacy_type=', 'node_sort_policy=', 'node_sort_policy_file=', 'conflict_policy=', 'conflict_policy_file=']
# create_res < --earliest_start=<epoch start boundary> | --resource_amount=<numberof nodes> > --duration=<duration seconds> --latest_end=<epoch end boundary> --resource_amount=<number of nodes> --job_restriction=<code> --job_restriction_file=<filename> --node_restriction=<code> --node_restriction_file=<filename> --type=<shared|private> --node_sort_policy=<code> --node_sort_policy_file=<filename> --conflict_policy=<code> --conflict_policy_file=<filename>
# - read in existing reservations from database
# - determine if adequate nodes are free for duration between start and end
# times
# - if so, put reservation for those nodes, with job_restriction in the
# database
# shelve module
# using shelve may limit the size of database objects, if dbm is
# the underlying interface.  shelve does not do locking.  pickle
# would require a little more work to handle additions, deletions
# searches, etc.  locking would be easier, since I would know what
# files are being used.
# locking an entire file, fcntl.flock can be used
# LOCK_SH for read, LOCK_EX for write, LOCK_UN to release
# need to make this atomic to the user, so that a Ctrl-C does not
# leave a lock hanging around...Looks like Unix releases the lock
# when the file is closed
# Lyn thinks reservations should be allowed to overlap, in the interest
# of allowing the administrator to do anything.  I need to allow
# overlapping reservations in order to enable setting of system down
# times, without creating a separate facility for this.  Here are the
# rules for reservations:
# - Reservations may overlap
# - If a reservation has type = shared, then other reservations on
#   the same nodes are sufficient to allow jobs on to those nodes.
# - If a reservation has type = private, then other reservations
#   are not sufficient to allow jobs on to those nodes.
# need different modes for create_res:
#   - if resource_amount not given, earliest_start and duration must be
#     provided.  In this case, as many nodes as possible will be allocated.
#   - if start_time is not given, resource_amount and duration must be
#     provided.  In this case, the earliest timeslot having that number of
#     nodes free will be allocated.
# The nodes allocated to a reservation, in reservation.node_list, will
# be created at reservation creation time.  It will not be updated, even
# if more nodes matching the node_restriction become available.  It can
# be updated, with modify_res (really, create_res and remove_res)
# There should be several distinct layers of hooks:
# - developer       (not needed)
# - integrator      (for someone installing the reservation system)
# - administrator   (for anyone controlling the reservation system)
# - user_as_administrator (for a user running an instance of the system
#   to control resources within his own reservation)
# - user            (for a someone to control his reservation)

import sys
import getopt
import fcntl, FCNTL
import shelve
import string
import os
import re
import rexec
import copy
import Catalina

RESERVATION_DB = 'reservations'
JOBS_DB = 'jobs'
RESOURCE_DB = 'resource'
result = 1

def reconcile_file_to_arg(dict, arg, filearg) :
    if dict.has_key(arg) and dict.has_key(filearg) :
        print "Can't specify both (%s) and (%s)" % (arg, filearg)
        sys.exit(1)
    elif dict.has_key(filearg) :
        if os.path.isfile(dict[filearg]) :
            input = open(dict[filearg], 'r')
            filestring = input.read()
            input.close()
            return filestring
        else :
            print "%s not a file!" % dict[filearg]
            sys.exit(1)
    elif dict.has_key(arg) :
        return dict[arg]
    else :
        print "dict[arg] is (%s)" % dict[arg]
        print "dict[filearg] is (%s)" % dict[filearg]
        return ''

def checkargs(argdict) :

    if argdict.has_key('--job_restriction') or argdict.has_key('--job_restriction_file') :
        job_restriction_code = reconcile_file_to_arg(
          argdict, '--job_restriction', '--job_restriction_file'
          )
        if job_restriction_code != '' :
            argdict['--job_restriction'] = job_restriction_code

    if argdict.has_key('--node_restriction') or argdict.has_key('--node_restriction_file') :
        node_restriction_code = reconcile_file_to_arg(
          argdict, '--node_restriction', '--node_restriction_file'
          )
        if node_restriction_code != '' :
            argdict['--node_restriction'] = node_restriction_code

    if argdict.has_key('--node_sort_policy') or argdict.has_key('--node_sort_policy_file') :
        policy_restriction_code = reconcile_file_to_arg(
          argdict, '--node_sort_policy', '--node_sort_policy_file'
          )
        if policy_restriction_code != '' :
            argdict['--node_sort_policy'] = policy_restriction_code

    if argdict.has_key('--conflict_policy') or argdict.has_key('--conflict_policy_file') :
        conflict_code = reconcile_file_to_arg(
          argdict, '--conflict_policy', '--conflict_policy_file'
          )
        if conflict_code != '' :
            argdict['--conflict_policy'] = conflict_code
    
    if argdict.has_key('--affinity_calculation') or argdict.has_key('--affinity_calculation_file') :
        affinity_calculation = reconcile_file_to_arg(
          argdict, '--affinity_calculation', '--affinity_calculation_file'
          )
        if affinity_calculation != '' :
            argdict['--affinity_calculation'] = affinity_calculation
    
    if argdict.has_key('--duration') and string.atol(argdict['--duration']) < 0 :
        print "--duration must be non-negative!"
        sys.exit(1)

    if argdict.has_key('--earliest_start') and string.atol(argdict['--earliest_start']) < 0 :
        print "--earliest_start must be non-negative!"
        sys.exit(1)

    if argdict.has_key('--latest_end') and string.atol(argdict['--latest_end']) < 0 :
        print "--latest_end must be non-negative!"
        sys.exit(1)

    if argdict.has_key('--earliest_start') and string.atol(argdict['--earliest_start']) > string.atol(argdict['--latest_end']) :
        print "--earliest_start must be earlier than --latest_end!"
        sys.exit(1)

    return argdict

options = ['job_step_id=', 'old_res_id=', 'earliest_start=', 'latest_end=', 'duration=', 'resource_amount=', 'job_restriction=', 'job_restriction_file=' 'node_restriction=', 'node_restriction_file=', 'privacy_type=', 'node_sort_policy=', 'node_sort_policy_file=', 'conflict_policy=', 'conflict_policy_file=', 'affinity_calculation=', 'affinity_calculation_file=', 'mode=', 'debug', 'comment=']
args = sys.argv[1:]
for arg in args :
    print "arg is (%s)" % arg
argdict = {}
optlist, lineargs = getopt.getopt(args, '', options)
for pair in optlist:
        # validity = re.match(argpats[pair[0]], pair[1])
        # if validity == None:
        #         print "Invalid option! %s=%s" % (pair[0],pair[1])
        # else:
        argdict[pair[0]] = pair[1]
        if pair[0] == '--node_restriction' :
            print "pair[1] is (%s)" % pair[1]
tempdict = checkargs(argdict)
argdict = tempdict

print "Opening the db..."
reservations_db_handle = Catalina.open_db(RESERVATION_DB,'write');
resources_db_handle = Catalina.open_db(RESOURCE_DB,'read');
jobs_db_handle = Catalina.open_db(JOBS_DB,'read');


if argdict.has_key('--old_res_id') :
    old_res_id = argdict['--old_res_id']
    if old_res_id == None :
        raise 'NoOldResID'
    reservations_dict = reservations_db_handle[0]
    if reservations_dict.has_key(old_res_id) :
        old_res = reservations_dict[old_res_id]
    else :
        raise 'KeyNotFound', old_res_id
else :
    old_res_id = None
if argdict.has_key('--debug') :
    Catalina.DEBUG = 'TRUE'
if argdict.has_key('--earliest_start') :
    earliest_start = string.atof(argdict['--earliest_start'])
else :
    earliest_start = old_res['start_time_float']
if argdict.has_key('--duration') :
    duration = string.atof(argdict['--duration'])
else :
    duration = old_res['duration_float']
if argdict.has_key('--latest_end') :
    latest_end = string.atof(argdict['--latest_end'])
else :
    latest_end = old_res['start_time_float'] + duration
if argdict.has_key('--resource_amount') :
    resource_amount = string.atoi(argdict['--resource_amount'])
else :
    resource_amount = old_res['resource_amount_int']
if argdict.has_key('--job_restriction') :
    job_restriction = argdict['--job_restriction']
else :
    job_restriction = old_res['job_restriction']
if argdict.has_key('--node_restriction') :
    node_restriction = argdict['--node_restriction']
else :
    node_restriction = old_res['node_restriction']
if argdict.has_key('--node_sort_policy') :
    node_sort_policy = argdict['--node_sort_policy']
else :
    node_sort_policy = old_res['node_sort_policy']
if argdict.has_key('--conflict_policy') :
    conflict_policy = argdict['--conflict_policy']
else :
    conflict_policy = old_res['conflict_policy']
if argdict.has_key('--affinity_calculation') :
    affinity_calculation = argdict['--affinity_calculation']
else :
    affinity_calculation = old_res['affinity_calculation']
if argdict.has_key('--privacy_type') :
    privacy_type = argdict['--privacy_type']
else :
    privacy_type = old_res['privacy_type_string']
if argdict.has_key('--comment') :
    comment = argdict['--comment']
else :
    comment = old_res['comment_string']
if argdict.has_key('--mode') :
    mode = argdict['--mode']
else :
    mode = 'lookahead'

try :
    new_res = Catalina.create_reservation(
      resources_db_handle=resources_db_handle,
      reservations_db_handle=reservations_db_handle,
      jobs_db_handle=jobs_db_handle,
      old_res_id=old_res_id,
      earliest_start_float=earliest_start,
      latest_end_float=latest_end,
      duration_float=duration,
      resource_amount_int=resource_amount,
      job_restriction=job_restriction,
      node_restriction=node_restriction,
      node_sort_policy=node_sort_policy,
      conflict_policy=conflict_policy,
      affinity_calculation=affinity_calculation,
      comment_string=comment,
      privacy_type_string=privacy_type,
      mode=mode
    )
except 'InsufficientNodes', new_res :
    print "Insufficient nodes found! "
    Catalina.close_db(reservations_db_handle)
    Catalina.close_db(resources_db_handle)
    Catalina.close_db(jobs_db_handle)
    sys.exit(1)

if mode == 'lookahead' :
    print "reservation possible on %s nodes with start_time %s for duration %s" % \
      ( new_res['resource_amount_int'],
        new_res['start_time_float'],
        new_res['duration_float'] )
else :
    print "reservation %s created on %s nodes with start_time %s for duration %s" % \
      ( new_res['name'],
        new_res['resource_amount_int'],
        new_res['start_time_float'],
        new_res['duration_float'] )


Catalina.close_db(reservations_db_handle)
Catalina.close_db(resources_db_handle)
Catalina.close_db(jobs_db_handle)

sys.exit(0)
@
