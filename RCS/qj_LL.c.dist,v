head	1.21;
access;
symbols;
locks; strict;
comment	@# @;


1.21
date	2007.02.16.23.38.15;	author kenneth;	state Exp;
branches;
next	1.20;

1.20
date	2007.02.02.00.03.14;	author mmargo;	state Exp;
branches;
next	1.19;

1.19
date	2007.02.01.21.45.51;	author mmargo;	state Exp;
branches;
next	1.18;

1.18
date	2006.11.21.22.55.13;	author mmargo;	state Exp;
branches;
next	1.17;

1.17
date	2006.03.22.18.19.57;	author mmargo;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.20.17.55.44;	author kenneth;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.10.18.05.41;	author kenneth;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.10.16.58.49;	author kenneth;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.10.15.43.53;	author kenneth;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.10.04.42.35;	author kenneth;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.02.21.07.53;	author kenneth;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.22.23.16.02;	author kenneth;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.28.20.06.38;	author kenneth;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.12.18.26.18;	author kenneth;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.11.22.18.43;	author kenneth;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.01.00.24.09;	author kenneth;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.05.17.55.12;	author kenneth;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.11.23.19.44;	author kenneth;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.10.21.40.04;	author kenneth;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.16.19.24.15;	author kenneth;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.11.22.28.01;	author kenneth;	state Exp;
branches;
next	;


desc
@query job for LL
@


1.21
log
@tack resourcespec and initiator to end of linked lists instead
of beginning
@
text
@/* C program to get job info through the LL Data Access API */
#include <stdio.h>
#include <math.h>
#include "/usr/lpp/LoadL/full/include/llapi.h"

/* Consumable Resource detection doesn't work, yet */

main (int argc, char *argv[]) {
/*
	char *stepstates[20] = {
		"STATE_IDLE", "STATE_PENDING", "STATE_STARTING", "STATE_RUNNING",
    "STATE_COMPLETE_PENDING", "STATE_REJECT_PENDING", "STATE_REMOVE_PENDING",
    "STATE_VACATE_PENDING", "STATE_COMPLETED", "STATE_REJECTED", "STATE_REMOVED",
    "STATE_VACATED", "STATE_CANCELED", "STATE_NOTRUN", "STATE_TERMINATED",
    "STATE_UNEXPANDED", "STATE_SUBMISSION_ERR", "STATE_HOLD", "STATE_DEFERRED",
    "STATE_NOTQUEUED"
	};
STATE_PREEMPTED, STATE_PREEMPT_PENDING,
                 STATE_RESUME_PENDING
*/
	char *stepstates[23] = {
		"Idle", "Pending", "Starting", "Running",
    "Complete_Pending", "Reject_Pending", "Remove_Pending",
    "Vacate_Pending", "Completed", "Rejected", "Removed",
    "Vacated", "Canceled", "NotRun", "Terminated",
    "Unexpanded", "Submission_Err", "Hold", "Deferred",
    "NotQueued","Preempted","Preempt_Pending","Resume_Pending"
	};
	char *UsageTypes[3] = {"SHARED", "NOT_SHARED", "SLICE_NOT_SHARED"};
/* stuff for the Data Access API */
	LL_element *query_element, *obj_element, *step_element, *node_element, *credential_element, *machine_element, *task_element, *resourcereq_element, *ti_element;
	/*for getting wall_clock_used*/
	LL_element *wall_query_element, *wall_obj_element, *wall_step_element;
	char *wall_step_list[2];
	char *wall_step_name;
	int err_code, obj_count;

	/*for getting adapter usage window name and memory */
	LL_element *adapter_usage_element;
	int *window_name, *window_memory;
	char *usage_tag;

	/*for getting adapter req info*/
	char *adreqtype_name;
	char *adreqprotocol;
	char *adreqmode;
	int adreqinstances;
	LL_element *adreq_element;

	int rc, error_code, number_of_objs, ti_count, first_te, first_ne;
	int ll_nodemininstances, ll_stepstate;
	int nodeinstancecounter;
	char *job_user, *job_group, *machine_name, *timachine_name;

	struct initiatornode {
		int nodeinitiators;
		char *noderequirementsptr;
		struct initiatornode *next_ptr;
	};
	struct initiatornode *new_initiatornodeptr;
	struct initiatornode *old_initiatornodeptr;
	struct initiatornode *initiatorcounter = NULL;

	struct resourcespec {
                int64_t value;
		char *resourcenameptr;
		struct resourcespec *next_ptr;
	};
	struct resourcespec *new_resourcespecptr;
	struct resourcespec *old_resourcespecptr;
	struct resourcespec *resourcespeccounter = NULL;

/*
	struct adapterwindow {
                int64_t memory;
		char *name;
		struct adapterwindow *next_ptr;
	};
	struct adapterwindow *new_adapterwindowptr;
	struct adapterwindow *adapterwindowcounter = NULL;
*/

	struct jobinfo {
		char *userptr;
		char *groupptr;
		char *accountptr;
		char *adreqmap;
		char *first_adreqtype_name;
		char *machinemap;
		char *first_machine_name;
		char *taskinstancemachinemap;
		char *taskinstanceadapterwindowmap;
		char *taskinstanceadapterwindowmemorymap;
		int *wall_clock_limitptr;
		int *wall_clock_usedptr;
		char *stateptr;
		int stateint;
		char *stepid;
		char *stepclass;
		char *commentptr;
		char *initiatormap;
		char *requirementsmap;
		char *resourcesreq;
		int *NodeUsage;
		char *reqstring;
		int *CompletionCodeptr;
		time_t *CompletionDate;
		time_t *SubmitTime;
		time_t *Dispatch_Time;
		struct initiatornode *job_firstinitptr;
		struct resourcespec *job_firstresourcespecptr;
		/*struct adapterwindow *job_firstadapterwindowptr;*/
		struct jobinfo *next_ptr;
	};
	struct jobinfo *first_job_ptr = NULL;
	struct jobinfo *new_job_ptr = NULL;
	struct jobinfo *jobnode = NULL;


/* Data Access API: */
	/* create a query_element of jobs */
	query_element = ll_query(JOBS);

	/* set the query request to all */
	rc = ll_set_request(query_element,QUERY_ALL, NULL, NULL);
	if (rc != 0) {
		exit(rc);
	}

	/* get an object element */
	obj_element = ll_get_objs(query_element, LL_CM, NULL, &number_of_objs, &error_code);

	/* for each job in the list... */
	while ( obj_element ) {

		/* get the credential */
		job_user = NULL;
		job_group = NULL;
		rc = ll_get_data(obj_element, LL_JobCredential, &credential_element);
		rc = ll_get_data(credential_element, LL_CredentialUserName, &job_user);
		rc = ll_get_data(credential_element, LL_CredentialGroupName, &job_group);

		/* get the first step... */
		rc = ll_get_data(obj_element, LL_JobGetFirstStep, &step_element);
		if (rc != 0) {
			exit(rc);
		}

		/* get the subsequent steps for the job */
		while ( step_element ) {

			/* allocate and initialize a new jobinfo object. */
			new_job_ptr = (struct jobinfo *)malloc(sizeof(struct jobinfo));
			new_job_ptr->job_firstinitptr = NULL;
			new_job_ptr->job_firstresourcespecptr = NULL;
			/*new_job_ptr->job_firstadapterwindowptr = NULL;*/
			new_job_ptr->next_ptr = first_job_ptr;
			first_job_ptr = new_job_ptr;

			new_job_ptr->wall_clock_limitptr = NULL;

			/* set userptr and groupptr to that of the job */
			new_job_ptr->userptr = job_user;
			new_job_ptr->groupptr = job_group;

			/* get the account_no of the job step */
			rc = ll_get_data(step_element, LL_StepAccountNumber, &(new_job_ptr->accountptr));
			if (rc != 0) {
				exit(rc);
			}

			/* get the submit time of the job */
			rc = ll_get_data(obj_element, LL_JobSubmitTime, &(new_job_ptr->SubmitTime));
			if (rc != 0) {
				exit(rc);
			}

			/* get the state of the job step */
			rc = ll_get_data(step_element, LL_StepState, &ll_stepstate);
			if (rc != 0) {
				exit(rc);
			}
			new_job_ptr->stateint = ll_stepstate;
			new_job_ptr->stateptr = (char *)malloc(strlen(stepstates[ll_stepstate]) + 1);
			strcpy(new_job_ptr->stateptr,stepstates[ll_stepstate]);

			/* get the id of the job step */
			rc = ll_get_data(step_element, LL_StepID, &(new_job_ptr->stepid));
			/*printf("doing (%s)\n", new_job_ptr->stepid);*/
			if (rc != 0) {
				exit(rc);
			}

			/* get the dispatch time of the job step */
			rc = ll_get_data(step_element, LL_StepDispatchTime, &(new_job_ptr->Dispatch_Time));
			if (rc != 0) {
				exit(rc);
			}

			/* get the class of the job step */
			rc = ll_get_data(step_element, LL_StepJobClass, &(new_job_ptr->stepclass));
			if (rc != 0) {
				exit(rc);
			}

			/* get the comment of the job step */
			rc = ll_get_data(step_element, LL_StepComment, &(new_job_ptr->commentptr));
			if (rc != 0) {
				exit(rc);
			}

			/* get the CompletionCode of the job step */
			new_job_ptr->CompletionCodeptr = NULL;
			rc = ll_get_data(step_element, LL_StepCompletionCode, &(new_job_ptr->CompletionCodeptr));
			if (rc != 0) {
				exit(rc);
			}

			/* get the wall_clock_limit of the job step */
			rc = ll_get_data(step_element, LL_StepWallClockLimitHard, &(new_job_ptr->wall_clock_limitptr));
			if (rc != 0) {
				exit(rc);
			}


			/* get the CompletionDate of the job step */
			new_job_ptr->CompletionDate = NULL;
			rc = ll_get_data(step_element, LL_StepCompletionDate, &(new_job_ptr->CompletionDate));
			if (rc != 0) {
				exit(rc);
			}

			/* get the NodeUsage of the job step */
			new_job_ptr->NodeUsage = NULL;
			rc = ll_get_data(step_element, LL_StepNodeUsage, &(new_job_ptr->NodeUsage));
			if (rc != 0) {
				exit(rc);
			}


			/*print out adapterreq info:
			LL_StepGetFirstAdapterReq LL_element
			LL_StepGetNextAdapterReq LL_element
AdapterReq LL_AdapterReqCommLevel  int*   A pointer to the integer indicating the
                                          adapter's communication level.
AdapterReq LL_AdapterReqInstances  int*   A pointer to an integer containing the
                                          requested adapter instances.
AdapterReq LL_AdapterReqMode       char** A pointer to a string containing the
                                          requested adapter mode (IP or US).
AdapterReq LL_AdapterReqProtocol   char** A pointer to a string containing the
                                          requested adapter protocol.
AdapterReq LL_AdapterReqRcxtBlocks int*   A pointer to the integer indicating the
                                          number of rCxt blocks requested for the
                                          adapter usage.
AdapterReq LL_AdapterReqTypeName   char** A pointer to a string containing the
                                          requested adapter type.
AdapterReq LL_AdapterReqUsage      int*   A pointer to the integer indicating the
                                          requested adapter usage. This integer
                                          will be one of the values defined in the
                                          Usage enum.
			*/

			
			adreqtype_name = NULL;
			adreqprotocol = NULL;
			adreqmode = NULL;
			new_job_ptr->adreqmap = (char *)malloc(strlen("") + 1);
			strcpy(new_job_ptr->adreqmap,"");
			/* get the first machine */
			rc = ll_get_data(step_element, LL_StepGetFirstAdapterReq, &adreq_element);
			rc = ll_get_data(adreq_element, LL_AdapterReqTypeName, &(new_job_ptr->first_adreqtype_name));
			if (rc == 0) {
				while ( adreq_element ) {
					/* get name of each machine */
					rc = ll_get_data(adreq_element, LL_AdapterReqTypeName, &adreqtype_name);
					if (rc == 0) {
						new_job_ptr->adreqmap = (char *)realloc(new_job_ptr->adreqmap, strlen(new_job_ptr->adreqmap) + strlen(adreqtype_name) + 1);
						strcat(new_job_ptr->adreqmap, adreqtype_name);
					}
					/* print separator '#cat_sep#' */
					new_job_ptr->adreqmap = (char *)realloc(new_job_ptr->adreqmap, strlen(new_job_ptr->adreqmap) + strlen("#cat_sep#") + 1);
					strcat(new_job_ptr->adreqmap, "#cat_sep#");
					/* get req instances each machine */
					rc = ll_get_data(adreq_element, LL_AdapterReqInstances, &adreqinstances);
					if (rc == 0) {
						new_job_ptr->adreqmap = (char *)realloc(new_job_ptr->adreqmap, strlen(new_job_ptr->adreqmap) + strlen(itoa(adreqinstances)) + 1);
						strcat(new_job_ptr->adreqmap, itoa(adreqinstances));
					}
					/* print separator '#cat_sep#' */
					new_job_ptr->adreqmap = (char *)realloc(new_job_ptr->adreqmap, strlen(new_job_ptr->adreqmap) + strlen("#cat_sep#") + 1);
					strcat(new_job_ptr->adreqmap, "#cat_sep#");
					/* get protocol */
					rc = ll_get_data(adreq_element, LL_AdapterReqProtocol, &adreqprotocol);
					if (rc == 0) {
						new_job_ptr->adreqmap = (char *)realloc(new_job_ptr->adreqmap, strlen(new_job_ptr->adreqmap) + strlen(adreqprotocol) + 1);
						strcat(new_job_ptr->adreqmap, adreqprotocol);
					}
					/* print separator '#cat_sep#' */
					new_job_ptr->adreqmap = (char *)realloc(new_job_ptr->adreqmap, strlen(new_job_ptr->adreqmap) + strlen("#cat_sep#") + 1);
					strcat(new_job_ptr->adreqmap, "#cat_sep#");
					/* get mode */
					rc = ll_get_data(adreq_element, LL_AdapterReqMode, &adreqmode);
					if (rc == 0) {
						new_job_ptr->adreqmap = (char *)realloc(new_job_ptr->adreqmap, strlen(new_job_ptr->adreqmap) + strlen(adreqmode) + 1);
						strcat(new_job_ptr->adreqmap, adreqmode);
					}

					rc = ll_get_data(step_element, LL_StepGetNextAdapterReq, &adreq_element);
					if (rc == 0) {
						if ( adreq_element != NULL ) {
							new_job_ptr->adreqmap = (char *)realloc(new_job_ptr->adreqmap, strlen(new_job_ptr->adreqmap) + strlen("+") + 1);
							strcat(new_job_ptr->adreqmap, "+");
						}
					}
				}
			}

			/* if state is Running or Starting, get machinemap */
/*STATE_PREEMPTED, STATE_PREEMPT_PENDING,
                 STATE_RESUME_PENDING*/
			new_job_ptr->machinemap = NULL;
			if ( ll_stepstate == STATE_RUNNING ||
			     ll_stepstate == STATE_STARTING ||
			     ll_stepstate == STATE_PREEMPTED ||
			     ll_stepstate == STATE_PREEMPT_PENDING ||
			     ll_stepstate == STATE_RESUME_PENDING ||
				ll_stepstate == STATE_REMOVE_PENDING) {
				machine_name = NULL;
				new_job_ptr->machinemap = (char *)malloc(strlen("") + 1);
				strcpy(new_job_ptr->machinemap,"");
				/* get the first machine */
				rc = ll_get_data(step_element, LL_StepGetFirstMachine, &machine_element);
				rc = ll_get_data(machine_element, LL_MachineName, &(new_job_ptr->first_machine_name));
				if (rc == 0) {
					while ( machine_element ) {
						/* get name of each machine */
						rc = ll_get_data(machine_element, LL_MachineName, &machine_name);
						if (rc == 0) {
							new_job_ptr->machinemap = (char *)realloc(new_job_ptr->machinemap, strlen(new_job_ptr->machinemap) + strlen(machine_name) + 1);
							strcat(new_job_ptr->machinemap, machine_name);
						}
						rc = ll_get_data(step_element, LL_StepGetNextMachine, &machine_element);
						if (rc == 0) {
							if ( machine_element != NULL ) {
								new_job_ptr->machinemap = (char *)realloc(new_job_ptr->machinemap, strlen(new_job_ptr->machinemap) + strlen("+") + 1);
								strcat(new_job_ptr->machinemap, "+");
							}
						}
					}
				}
			}

			/* initialize the taskinstancemachinemap string */
			timachine_name = NULL;
			new_job_ptr->taskinstancemachinemap = (char *)malloc(strlen("") + 1);
			strcpy(new_job_ptr->taskinstancemachinemap,"");

			/* initialize the taskinstanceadapterwindowmap string */
			new_job_ptr->taskinstanceadapterwindowmap = (char *)malloc(strlen("") + 1);
			strcpy(new_job_ptr->taskinstanceadapterwindowmap,"");

			/* get the first Node spec */
			rc = ll_get_data(step_element, LL_StepGetFirstNode, &node_element);
			if (rc != 0) {
				exit(rc);
			}

			/* iterate through Node specifications */
			first_ne = 1;
			old_initiatornodeptr = NULL;
			old_resourcespecptr = NULL;
			while ( node_element ) {
				/*printf("getting info from new node_element\n");*/

				/* get the Consumable Resources requested by the job.  Take only the first Task of the first Node. */
				/* for #@@task_geometry jobs, need taskinstances for all Nodes. */
				task_element = (LL_element *)malloc(sizeof(query_element));
				rc = ll_get_data(node_element, LL_NodeGetFirstTask, &(task_element));
				/*free(task_element);*/
				/* kludge to skip first task element Master Task? */
				/*
				task_element = (LL_element *)malloc(sizeof(query_element));
				rc = ll_get_data(node_element, LL_NodeGetNextTask, &(task_element));
				*/
				/*printf("getting info from each task_element\n");*/
				first_te = 1;
				while (task_element != NULL) {
					/*printf("getting info from new task_element\n");*/
					resourcereq_element = (LL_element *)malloc(sizeof(query_element));
					rc = ll_get_data(task_element, LL_TaskGetFirstResourceRequirement, &(resourcereq_element));
					while (resourcereq_element != NULL) {
						new_resourcespecptr = (struct resourcespec *)malloc(sizeof(struct resourcespec));
						rc = ll_get_data(resourcereq_element, LL_ResourceRequirementName, &(new_resourcespecptr->resourcenameptr));
						rc = ll_get_data(resourcereq_element, LL_ResourceRequirementValue64, &(new_resourcespecptr->value));
						new_resourcespecptr->next_ptr = NULL;
						if (new_job_ptr->job_firstresourcespecptr == NULL) {
							new_job_ptr->job_firstresourcespecptr = new_resourcespecptr;
							old_resourcespecptr = new_resourcespecptr;
						} else {
							old_resourcespecptr->next_ptr = new_resourcespecptr;
							old_resourcespecptr = new_resourcespecptr;
						}
						resourcereq_element = (LL_element *)malloc(sizeof(query_element));
						rc = ll_get_data(task_element, LL_TaskGetNextResourceRequirement, &(resourcereq_element));
					}
	
					/* kludge to discard first ti */
					if ( first_te == 1 && first_ne == 1 ) {
						task_element = (LL_element *)malloc(sizeof(query_element));
						rc = ll_get_data(node_element, LL_NodeGetNextTask, &(task_element));
						/*printf("first_te is 1\n");*/
						first_te = 0;
						continue;
					} else {
						/*printf("first_te is (%d)\n", first_te);*/
					}
	
					/* put task instance loop here */
					/* get the first taskinstance */
					rc = ll_get_data(task_element, LL_TaskTaskInstanceCount, &ti_count);
					ti_element = (LL_element *)malloc(sizeof(query_element));
					rc = ll_get_data(task_element, LL_TaskGetFirstTaskInstance, &ti_element);
					if (rc != 0) {
						exit(rc);
					}
					while ( ti_element ) {
						/* get name of each task_instance */
						rc = ll_get_data(ti_element, LL_TaskInstanceMachineName, &timachine_name);
						if (rc != 0) {
							exit(rc);
						}
						/*printf("timachine_name (%s)\n", timachine_name);*/
						new_job_ptr->taskinstancemachinemap = (char *)realloc(new_job_ptr->taskinstancemachinemap, strlen(new_job_ptr->taskinstancemachinemap) + strlen(timachine_name) + 1);
						strcat(new_job_ptr->taskinstancemachinemap, timachine_name);
						new_job_ptr->taskinstanceadapterwindowmap = (char *)realloc(new_job_ptr->taskinstanceadapterwindowmap, strlen(new_job_ptr->taskinstanceadapterwindowmap) + strlen(timachine_name) + strlen(":") + 1);
						strcat(new_job_ptr->taskinstanceadapterwindowmap, timachine_name);
						strcat(new_job_ptr->taskinstanceadapterwindowmap, "-");
						/* get all adapter usages and get allocated adapter window name for each usage */
/*
						new_job_ptr->taskinstanceadapterwindowmap = (char *)malloc(strlen("") + 1);
						strcpy(new_job_ptr->taskinstanceadapterwindowmap,"");
						new_job_ptr->taskinstanceadapterwindowmemorymap = (char *)malloc(strlen("") + 1);
						strcpy(new_job_ptr->taskinstanceadapterwindowmemorymap,"");
*/
						rc = ll_get_data(ti_element, LL_TaskInstanceGetFirstAdapterUsage, &adapter_usage_element);
						while (adapter_usage_element) {
							rc = ll_get_data(adapter_usage_element, LL_AdapterUsageTag, &usage_tag);
							new_job_ptr->taskinstanceadapterwindowmap = (char *)realloc(new_job_ptr->taskinstanceadapterwindowmap, strlen(new_job_ptr->taskinstanceadapterwindowmap) + strlen(usage_tag) + 1);
							strcat(new_job_ptr->taskinstanceadapterwindowmap, usage_tag);
							new_job_ptr->taskinstanceadapterwindowmap = (char *)realloc(new_job_ptr->taskinstanceadapterwindowmap, strlen(new_job_ptr->taskinstanceadapterwindowmap) + strlen("@@") + 1);
							strcat(new_job_ptr->taskinstanceadapterwindowmap, "@@");
							rc = ll_get_data(adapter_usage_element, LL_AdapterUsageWindow, &window_name);
							new_job_ptr->taskinstanceadapterwindowmap = (char *)realloc(new_job_ptr->taskinstanceadapterwindowmap, strlen(new_job_ptr->taskinstanceadapterwindowmap) + strlen(itoa(window_name)) + 1);
							strcat(new_job_ptr->taskinstanceadapterwindowmap, itoa(window_name));
/*
							rc = ll_get_data(adapter_usage_element, LL_AdapterUsageWindowMemory, &window_memory);
							new_job_ptr->taskinstanceadapterwindowmemorymap = (char *)realloc(new_job_ptr->taskinstanceadapterwindowmemorymap, strlen(new_job_ptr->taskinstanceadapterwindowmemorymap) + strlen(itoa(window_memory)) + 1);
							strcat(new_job_ptr->taskinstanceadapterwindomemorywmap, itoa(window_memory));
*/
							rc = ll_get_data(ti_element, LL_TaskInstanceGetNextAdapterUsage, &adapter_usage_element);
							if (adapter_usage_element != NULL) {
								new_job_ptr->taskinstanceadapterwindowmap = (char *)realloc(new_job_ptr->taskinstanceadapterwindowmap, strlen(new_job_ptr->taskinstanceadapterwindowmap) + strlen(",") + 1);
								strcat(new_job_ptr->taskinstanceadapterwindowmap, ",");
							}
							/* if adapter_usage_element is not NULL put a separator in for next adapter usage */
						}
						rc = ll_get_data(task_element, LL_TaskGetNextTaskInstance, &ti_element);
						if (rc != 0) {
							exit(rc);
						}
						if ( ti_element != NULL ) {
							new_job_ptr->taskinstancemachinemap = (char *)realloc(new_job_ptr->taskinstancemachinemap, strlen(new_job_ptr->taskinstancemachinemap) + strlen("+") + 1);
							strcat(new_job_ptr->taskinstancemachinemap, "+");
							new_job_ptr->taskinstanceadapterwindowmap = (char *)realloc(new_job_ptr->taskinstanceadapterwindowmap, strlen(new_job_ptr->taskinstanceadapterwindowmap) + strlen("+") + 1);
							strcat(new_job_ptr->taskinstanceadapterwindowmap, "+");
						}
					}
	
					/*free(task_element);*/
					task_element = (LL_element *)malloc(sizeof(query_element));
					rc = ll_get_data(node_element, LL_NodeGetNextTask, &(task_element));
				}
				/*free(resourcereq_element);*/
				/*free(task_element);*/


				/* get NodeMinInstances, minimum number of nodes that should be run with this node specification */
				rc = ll_get_data(node_element, LL_NodeMinInstances, &ll_nodemininstances);
				if (rc != 0) {
					exit(rc);
				}

				/* Use NodeMinInstances from above, to create an initiator node for each required node *
				 * Each initiator node stores the number of tasks for that node instance               */
				for ( nodeinstancecounter = 1 ; nodeinstancecounter <= ll_nodemininstances ; nodeinstancecounter++ ) {
					new_initiatornodeptr = (struct initiatornode *)malloc(sizeof(struct initiatornode));
					/* get NodeInitiatorCount, the number of tasks started on each node of this spec */
					rc = ll_get_data(node_element, LL_NodeInitiatorCount, &(new_initiatornodeptr->nodeinitiators));
					if (rc != 0) {
						exit(rc);
					}
					/* get NodeRequirements */
					rc = ll_get_data(node_element, LL_NodeRequirements, &(new_initiatornodeptr->noderequirementsptr));
					if (rc != 0) {
						exit(rc);
					}
					new_initiatornodeptr->next_ptr = NULL;
					if ( new_job_ptr->job_firstinitptr == NULL ) {
						new_job_ptr->job_firstinitptr = new_initiatornodeptr;
					        old_initiatornodeptr = new_initiatornodeptr;
					} else {
						old_initiatornodeptr->next_ptr = new_initiatornodeptr;
						old_initiatornodeptr = new_initiatornodeptr;
					}
				}





				rc = ll_get_data(step_element, LL_StepGetNextNode, &node_element);
				if (rc != 0) {
					exit(rc);
				}
				if ( node_element != NULL ) {
					new_job_ptr->taskinstancemachinemap = (char *)realloc(new_job_ptr->taskinstancemachinemap, strlen(new_job_ptr->taskinstancemachinemap) + strlen("+") + 1);
					strcat(new_job_ptr->taskinstancemachinemap, "+");
				}
				first_ne = 0;
			}
			/* get the next step */
			rc = ll_get_data(obj_element, LL_JobGetNextStep, &step_element);
			if (rc != 0) {
				exit(rc);
			}
		}

		obj_element = ll_next_obj(query_element);
        }
        ll_free_objs(query_element);
        ll_deallocate(query_element);

	jobnode = first_job_ptr;
	while ( jobnode != NULL ) {
		/*printf("state:%s#cat_delim#", jobnode->stateptr);*/
			if ( jobnode->stateint == STATE_RUNNING ||
			     jobnode->stateint == STATE_STARTING ||
			     jobnode->stateint == STATE_PREEMPTED ||
			     jobnode->stateint == STATE_PREEMPT_PENDING ||
			     jobnode->stateint == STATE_RESUME_PENDING ||
				jobnode->stateint == STATE_REMOVE_PENDING) {
				/* get the wall_clock_used of the job step */
				jobnode->wall_clock_usedptr = NULL;
				wall_step_list[0] = jobnode->stepid;
				wall_step_list[1] = NULL;
				wall_query_element = ll_query(JOBS);
				if ( wall_query_element != NULL ) {
					rc = ll_set_request(wall_query_element, QUERY_STEPID, wall_step_list, ALL_DATA);
					wall_obj_element = ll_get_objs(wall_query_element, LL_STARTD, jobnode->first_machine_name, &obj_count, &err_code);
					/* bug #558 : Continue scheduling even when LoadL API fails */
					/* change : jobnode->stateptr, jobnode->wall_clock_usedptr, */
					if (wall_obj_element == NULL) {
						/* job is terminating, so let's move on to the next job.
						This block of code is exception handling code */
						
						/* Assume that job's state is completed, array index 8 */
						 
						jobnode->stateptr = (char *)malloc(strlen(stepstates[STATE_REMOVED]) + 1);
						strcpy(jobnode->stateptr,stepstates[STATE_REMOVED]);
						
						/* Assume that job's wall clock used ptr is full wallclock */
						int zero = 0;
						int * zeroptr = zero;
						
						jobnode->wall_clock_usedptr= zeroptr;
						
						
						jobnode = jobnode->next_ptr;
						continue;
					}
					
					
					/* loop over all the steps form the startd until we get to the current stepid */
					rc = ll_get_data(wall_obj_element, LL_JobGetFirstStep, &wall_step_element);
					/* Added by Martin Margo on 2/3/2006 */
					if(rc != 0 ) {
						exit(rc);
					}
					while (wall_step_element) {
						rc = ll_get_data(wall_step_element, LL_StepID, &wall_step_name);
						if ( ! strncmp(jobnode->stepid,wall_step_name, strlen(jobnode->stepid))) {
							ll_get_data(wall_step_element, LL_StepWallClockUsed, &(jobnode->wall_clock_usedptr));
							break;
						}
						ll_get_data(wall_obj_element, LL_JobGetNextStep, &wall_step_element);
					}
	        			rc = ll_free_objs(wall_query_element);
					if (rc) {
						printf("ll_free_objs(wall_query_element) failed with rc(%d)!\n", rc);
						exit(rc);
					}
	        			rc = ll_deallocate(wall_query_element);
					if (rc) {
						printf("ll_deallocate(wall_query_element) failed with rc(%d)!\n", rc);
						exit(rc);
					}
				} else {
					printf ("Could not get wall_query_element!\n");
					exit(1);
				}
				if (rc != 0) {
					exit(rc);
				}
			} else {
				jobnode->wall_clock_usedptr = NULL;
			}
		jobnode = jobnode->next_ptr;
	}

/* Now, print out a line for each job we found
 * we do one requirement string here for each node,
 * since that's how it is in the IBM data structure.
 * Perhaps they want to someday specify job requirements
 * for each node in the structure?  Until then, the user
 * can parse these out
*/
	jobnode = first_job_ptr;
	while ( jobnode != NULL ) {
		printf("user:%s#cat_delim#", jobnode->userptr);
		printf("group:%s#cat_delim#", jobnode->groupptr);
		printf("account:%s#cat_delim#", jobnode->accountptr);
		printf("state:%s#cat_delim#", jobnode->stateptr);
		printf("wall_clock_limit:%d#cat_delim#", jobnode->wall_clock_limitptr);
		printf("wall_clock_used:%d#cat_delim#", jobnode->wall_clock_usedptr);
		printf("stepid:%s#cat_delim#", jobnode->stepid);
		printf("class:%s#cat_delim#", jobnode->stepclass);
		printf("node_usage:%s#cat_delim#", UsageTypes[(int)jobnode->NodeUsage]);
		printf("taskinstancemachinemap:%s#cat_delim#", jobnode->taskinstancemachinemap);
		printf("taskinstanceadapterwindowmap:%s#cat_delim#", jobnode->taskinstanceadapterwindowmap);
		printf("dispatchtime:%d#cat_delim#", jobnode->Dispatch_Time);
		printf("submittime:%d#cat_delim#", jobnode->SubmitTime);
		if (jobnode->CompletionDate != NULL) {
			printf("completiontime:%d#cat_delim#", jobnode->CompletionDate);
		}
		if (jobnode->CompletionCodeptr != NULL) {
			printf("completioncode:%d#cat_delim#", jobnode->CompletionCodeptr);
		}
		initiatorcounter = jobnode->job_firstinitptr;
		jobnode->initiatormap = (char *)malloc(strlen("") + 1);
		strcpy(jobnode->initiatormap,"");
		jobnode->requirementsmap = (char *)malloc(strlen("") + 1);
		strcpy(jobnode->requirementsmap,"");
		while ( initiatorcounter != NULL ) {
			jobnode->initiatormap = (char *)realloc(jobnode->initiatormap, strlen(jobnode->initiatormap) + sizeof(itoa(initiatorcounter->nodeinitiators)) + 1);
			strcat(jobnode->initiatormap, itoa(initiatorcounter->nodeinitiators));
			jobnode->requirementsmap = (char *)realloc(jobnode->requirementsmap, strlen(jobnode->requirementsmap) + strlen(initiatorcounter->noderequirementsptr) + 1);
			strcat(jobnode->requirementsmap, initiatorcounter->noderequirementsptr);
			initiatorcounter = initiatorcounter->next_ptr;
			if ( initiatorcounter != NULL ) {
				jobnode->initiatormap = (char *)realloc(jobnode->initiatormap, strlen(jobnode->initiatormap) + strlen("+") + 1);
				strcat(jobnode->initiatormap, "+");
				jobnode->requirementsmap = (char *)realloc(jobnode->requirementsmap, strlen(jobnode->requirementsmap) + strlen("+") + 1);
				strcat(jobnode->requirementsmap, "+");
			}
		}
		printf("requirementsmap:%s#cat_delim#", jobnode->requirementsmap);
		printf("resourcesreq:");
		resourcespeccounter = jobnode->job_firstresourcespecptr;
		while ( resourcespeccounter != NULL ) {
			printf("%s#cat_sep#%llu", resourcespeccounter->resourcenameptr,resourcespeccounter->value);
			resourcespeccounter = resourcespeccounter->next_ptr;
			if (resourcespeccounter != NULL){
				printf("+");
			}
		}
		printf("#cat_delim#");
		printf("comment:%s#cat_delim#", jobnode->commentptr);
		printf("initiatormap:%s#cat_delim#", jobnode->initiatormap);
		printf("machinemap:%s#cat_delim#", jobnode->machinemap);
		printf("adreqmap:%s#cat_delim#", jobnode->adreqmap);
	
		printf("\n");
		free(jobnode->requirementsmap);
		free(jobnode->initiatormap);
		jobnode = jobnode->next_ptr;
	}
	printf("qj FINISHED\n");
}
@


1.20
log
@fix minor bugs (enum STATE REMOVED and zero ptr to wall_clock_used_ptr)
mmargo
@
text
@d43 7
d61 1
d70 1
d87 2
d240 78
d370 2
d395 8
a402 2
						new_resourcespecptr->next_ptr = new_job_ptr->job_firstresourcespecptr;
						new_job_ptr->job_firstresourcespecptr = new_resourcespecptr;
d507 8
a514 2
					new_initiatornodeptr->next_ptr = new_job_ptr->job_firstinitptr;
					new_job_ptr->job_firstinitptr = new_initiatornodeptr;
d680 1
@


1.19
log
@bug 558, force artificial attributes to jobs that encounter null wallclock_element
mmargo
@
text
@d464 3
a466 3
						jobnode->stateint = 8; 
						jobnode->stateptr = (char *)malloc(strlen(stepstates[jobnode->stateint]) + 1);
						strcpy(jobnode->stateptr,stepstates[jobnode->stateint]);
d469 4
a472 1
						jobnode->wall_clock_usedptr= jobnode->wall_clock_limitptr;
@


1.18
log
@fix bug 558
mmargo
@
text
@d458 1
d462 10
d476 1
@


1.17
log
@add error handling code to prevent segmentation fault
mmargo
@
text
@a454 1
					
a455 5
					if( rc !=0 ) {
						printf("ll_set_request(wall_query_element, QUERY_STEPID... fails with rc = %d\n", rc);
						exit(rc);
					}
					
d457 6
a462 3
					if ( wall_obj_element == NULL){
						printf("wall_obj_element is null, exiting\n");
						exit(-1);
a464 1
					
d467 2
a468 2
					if(rc != 0){
						printf("outer ll_get_data fails with rc = %d\n",rc);
a470 2
					
					
a472 5
						if (rc != 0 ){
							printf("inner ll_get_data fails with rc = %d\n", rc);
							exit(rc);
						}
						
d474 1
a474 5
							rc = ll_get_data(wall_step_element, LL_StepWallClockUsed, &(jobnode->wall_clock_usedptr));
							if (rc != 0 ){
								printf("ll_get_data LL_stepwallclock used fail with rc = %d\n", rc);
								exit(rc);
							}
@


1.16
log
@remove bad deallocate
@
text
@d455 1
d457 5
d463 6
d471 6
d479 5
d485 5
a489 1
							ll_get_data(wall_step_element, LL_StepWallClockUsed, &(jobnode->wall_clock_usedptr));
@


1.15
log
@separate out wall_clock_used query.  Apparently, you can't nest ll_queries.
@
text
@a432 7
			/* deallocate of the wall elements is
			done here, since this program segfaults if
			it is up in with wall routine */
/*
	        			ll_free_objs(wall_obj_element);
*/
					ll_deallocate(wall_query_element);
@


1.14
log
@free_objs the wrong way, but it runs
@
text
@d86 1
d172 1
a263 37
			if ( ll_stepstate == STATE_RUNNING ||
			     ll_stepstate == STATE_STARTING ||
			     ll_stepstate == STATE_PREEMPTED ||
			     ll_stepstate == STATE_PREEMPT_PENDING ||
			     ll_stepstate == STATE_RESUME_PENDING ||
				ll_stepstate == STATE_REMOVE_PENDING) {
				/* get the wall_clock_used of the job step */
				new_job_ptr->wall_clock_usedptr = NULL;
				wall_step_list[0] = new_job_ptr->stepid;
				wall_step_list[1] = NULL;
				wall_query_element = ll_query(JOBS);
				if ( wall_query_element != NULL ) {
					rc = ll_set_request(wall_query_element, QUERY_STEPID, wall_step_list, ALL_DATA);
					wall_obj_element = ll_get_objs(wall_query_element, LL_STARTD, new_job_ptr->first_machine_name, &obj_count, &err_code);
					/* loop over all the steps form the startd until we get to the current stepid */
					rc = ll_get_data(wall_obj_element, LL_JobGetFirstStep, &wall_step_element);
					while (wall_step_element) {
						rc = ll_get_data(wall_step_element, LL_StepID, &wall_step_name);
						if ( ! strncmp(new_job_ptr->stepid,wall_step_name, strlen(new_job_ptr->stepid))) {
							ll_get_data(wall_step_element, LL_StepWallClockUsed, &(new_job_ptr->wall_clock_usedptr));
							break;
						}
						ll_get_data(wall_obj_element, LL_JobGetNextStep, &wall_step_element);
					}
	        			ll_free_objs(wall_obj_element);
/*
	        			ll_deallocate(wall_query_element);
*/
				} else {
					printf ("Could not get wall_query_element!\n");
					exit(1);
				}
				if (rc != 0) {
					exit(rc);
				}
			}

d444 1
a444 1
        ll_free_objs(obj_element);
d447 50
@


1.13
log
@free_obj on query_element, rather than objects
@
text
@d286 2
a287 1
	        			ll_free_objs(wall_query_element);
d289 1
d473 1
a474 1
*/
d479 1
a479 1
        ll_free_objs(query_element);
@


1.12
log
@move free and deallocate
@
text
@d286 1
a286 2
	        			ll_free_objs(wall_obj_element);
/*
a287 1
*/
d471 1
a472 1
					ll_deallocate(wall_query_element);
d477 1
a477 1
        ll_free_objs(obj_element);
@


1.11
log
@free wall object after ll_getdata to try to avoid seg faults
@
text
@d286 1
a287 1
	        			ll_free_objs(wall_obj_element);
d471 1
d473 1
@


1.10
log
@move deallocate of wall_element to end of loop.  otherwise, it
messes up the pointers in the interface.
@
text
@d53 1
a53 5
	struct initiatornode *new_initiatornodeptr = {
		0,
		NULL,
		NULL
	};
d61 1
a61 5
	struct resourcespec *new_resourcespecptr = {
		0,
		NULL,
		NULL
	};
d286 1
a287 1
/*
d471 1
@


1.9
log
@add preemption
@
text
@d53 5
a57 1
	struct initiatornode *new_initiatornodeptr;
d65 5
a69 1
	struct resourcespec *new_resourcespecptr;
d156 2
a214 1
			new_job_ptr->wall_clock_limitptr = NULL;
d295 1
d297 1
d476 4
a479 1

@


1.8
log
@ignore first task element of first node element for task instance machine name
@
text
@d18 2
d21 1
a21 1
	char *stepstates[20] = {
d27 1
a27 1
    "NotQueued"
d32 11
d64 10
d79 1
d81 2
d84 1
d100 1
d144 1
d211 1
d227 2
d232 3
d241 1
d261 35
d301 4
d370 32
d409 2
d487 1
d492 1
@


1.7
log
@generate machinemap for RP jobs
@
text
@d30 1
a30 1
	int rc, error_code, number_of_objs, ti_count;
a200 5
				/* get the first machine */
				rc = ll_get_data(step_element, LL_StepGetFirstMachine, &machine_element);
				if (rc != 0) {
					exit(rc);
				}
d204 17
a220 15
				while ( machine_element ) {
					/* get name of each machine */
					rc = ll_get_data(machine_element, LL_MachineName, &machine_name);
					if (rc != 0) {
						exit(rc);
					}
					new_job_ptr->machinemap = (char *)realloc(new_job_ptr->machinemap, strlen(new_job_ptr->machinemap) + strlen(machine_name) + 1);
					strcat(new_job_ptr->machinemap, machine_name);
					rc = ll_get_data(step_element, LL_StepGetNextMachine, &machine_element);
					if (rc != 0) {
						exit(rc);
					}
					if ( machine_element != NULL ) {
						new_job_ptr->machinemap = (char *)realloc(new_job_ptr->machinemap, strlen(new_job_ptr->machinemap) + strlen("+") + 1);
						strcat(new_job_ptr->machinemap, "+");
d237 1
d239 1
d247 1
d250 1
d252 1
d254 1
d267 10
a288 1
						/*printf("timachine_name (%s)\n", timachine_name);*/
d292 1
d349 1
@


1.6
log
@ignore first task, Master task?  Count all task instance machine names for
all nodes.  Necessary for task_geometry
@
text
@d199 2
a200 1
			     ll_stepstate == STATE_STARTING ) {
@


1.5
log
@smp
@
text
@d145 1
d227 5
a236 15
			/* get the Consumable Resources requested by the job.  Take only the first Task of the first Node. */
			task_element = (LL_element *)malloc(sizeof(query_element));
			rc = ll_get_data(node_element, LL_NodeGetFirstTask, &(task_element));
			while (task_element != NULL) {
				resourcereq_element = (LL_element *)malloc(sizeof(query_element));
				rc = ll_get_data(task_element, LL_TaskGetFirstResourceRequirement, &(resourcereq_element));
				while (resourcereq_element != NULL) {
					new_resourcespecptr = (struct resourcespec *)malloc(sizeof(struct resourcespec));
					rc = ll_get_data(resourcereq_element, LL_ResourceRequirementName, &(new_resourcespecptr->resourcenameptr));
					rc = ll_get_data(resourcereq_element, LL_ResourceRequirementValue64, &(new_resourcespecptr->value));
					new_resourcespecptr->next_ptr = new_job_ptr->job_firstresourcespecptr;
					new_job_ptr->job_firstresourcespecptr = new_resourcespecptr;
					resourcereq_element = (LL_element *)malloc(sizeof(query_element));
					rc = ll_get_data(task_element, LL_TaskGetNextResourceRequirement, &(resourcereq_element));
				}
d238 2
d241 20
a260 16
				/* put task instance loop here */
				/* get the first taskinstance */
				rc = ll_get_data(task_element, LL_TaskTaskInstanceCount, &ti_count);
				ti_element = (LL_element *)malloc(sizeof(query_element));
				rc = ll_get_data(task_element, LL_TaskGetFirstTaskInstance, &ti_element);
				if (rc != 0) {
					exit(rc);
				}
				timachine_name = NULL;
				new_job_ptr->taskinstancemachinemap = (char *)malloc(strlen("") + 1);
				strcpy(new_job_ptr->taskinstancemachinemap,"");
				while ( ti_element ) {
					/* get name of each task_instance */
					rc = ll_get_data(ti_element, LL_TaskInstanceMachineName, &timachine_name);
					if (rc != 0) {
						exit(rc);
d262 7
a268 3
					new_job_ptr->taskinstancemachinemap = (char *)realloc(new_job_ptr->taskinstancemachinemap, strlen(new_job_ptr->taskinstancemachinemap) + strlen(timachine_name) + 1);
					strcat(new_job_ptr->taskinstancemachinemap, timachine_name);
					rc = ll_get_data(task_element, LL_TaskGetNextTaskInstance, &ti_element);
d272 17
a288 3
					if ( ti_element != NULL ) {
						new_job_ptr->taskinstancemachinemap = (char *)realloc(new_job_ptr->taskinstancemachinemap, strlen(new_job_ptr->taskinstancemachinemap) + strlen("+") + 1);
						strcat(new_job_ptr->taskinstancemachinemap, "+");
d290 4
d295 2
a298 12



				task_element = (LL_element *)malloc(sizeof(query_element));
				rc = ll_get_data(node_element, LL_NodeGetNextTask, &(task_element));
			}
			/*free(resourcereq_element);*/
			/*free(task_element);*/

			/* iterate through Node specifications */
			while ( node_element ) {

d331 4
@


1.4
log
@changed sizeof(LL_element) to sizeof(query_element)
@
text
@d27 1
d29 2
a30 2
	LL_element *query_element, *obj_element, *step_element, *node_element, *credential_element, *machine_element, *task_element, *resourcereq_element;
	int rc, error_code, number_of_objs;
d33 1
a33 1
	char *job_user, *job_group, *machine_name;
d56 1
d64 2
a65 1
		char *resourcesmap;
d188 7
d246 35
d314 4
a322 1

d352 2
d381 1
a381 1
		printf("resourcesmap:");
@


1.3
log
@extract consumable resources requested
@
text
@d222 1
a222 1
			task_element = (LL_element *)malloc(sizeof(LL_element));
d225 1
a225 1
				resourcereq_element = (LL_element *)malloc(sizeof(LL_element));
d233 1
a233 1
					resourcereq_element = (LL_element *)malloc(sizeof(LL_element));
d236 1
a236 1
				task_element = (LL_element *)malloc(sizeof(LL_element));
@


1.2
log
@added print of qj FINISHED
@
text
@d6 1
d28 1
a28 1
	LL_element *query_element, *obj_element, *step_element, *node_element, *credential_element, *machine_element;
d42 8
d62 1
d69 1
d112 1
d221 20
d331 10
@


1.1
log
@Initial revision
@
text
@d72 3
d91 3
d110 3
d116 3
d122 3
d130 3
d136 3
d142 3
d148 3
d155 3
d162 3
d169 3
d179 3
d188 3
d194 3
d206 3
d215 3
d225 3
d230 3
d238 3
d245 3
d308 1
@
